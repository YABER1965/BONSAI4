---
title: QEUR23_INDHS28 - 閑話休題～紫微斗数をやってみる(カップル版中間)
date: 2025-07-31
tags: ["QEUシステム", "メトリックス", "Python言語", "Unsloth", "LLM", "データセット", "BONSAI", "LangGraph"]
excerpt: あたらしいLLMの学習体系を確立する
---

## QEUR23_INDHS28 - 閑話休題～紫微斗数をやってみる(カップル版中間)

## ～  腰が抜けた！ ～

QEU:FOUNDER ： “前回で「お似合いのカップル」の命盤が明らかになりました。次は、中間処理になります。”

![imageINDS1-19-1](/2025-07-31-QEUR23_INDHS28/imageINDS1-19-1.jpg) 

D先生： “はあ、「カップル」ねえ・・・（笑）。さて、もともとは2分割（前半、後半）の設計だったのが、3分割になったんですか？”

![imageINDS1-19-2](/2025-07-31-QEUR23_INDHS28/imageINDS1-19-2.jpg) 

QEU:FOUNDER ： “手順があまりにも複雑になり、プログラムが長くなるんです。最も大きな問題は、紫微斗数は**西洋占星術のようにパッケージが整備されていない**からでしょう。インプットは、もう知っているよね？今回のプログラムのアウトプットは、インプットした年の運勢「流年」の表です。”

D先生： “それでは、プログラムを見てみましょう。全部、一気に見ましょうか・・・。 “

```python
# ---
### 中間処理プログラム
import datetime
import pandas as pd
import json
from typing import Dict, List, Tuple, Any
import numpy as np
import japanize_matplotlib
import matplotlib.pyplot as plt
import matplotlib.font_manager as fm
import os
import re
import shutil
from lunarcalendar import Converter, Solar, Lunar
import traceback
# LangChain関連のインポート
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate, SystemMessagePromptTemplate, Human-MessagePromptTemplate
# JsonOutputParserのインポート処理を修正
try:
    # 新しいバージョン用
    from langchain_core.output_parsers import JsonOutputParser
except ImportError:
    # 古いバージョン用
    from langchain.output_parsers import JsonOutputParser
from langgraph.graph import StateGraph, END
import openpyxl
from openpyxl.styles import Alignment, Border, Side, Font
from openpyxl.utils import get_column_letter
# ---
class ZiWeiDouShuIntermediate:
    def __init__(self):
        print("INFO: Initializing ZiWeiDouShuIntermediate...")
        # 108星の分類
        self.main_stars = ["紫微", "天機", "太陽", "武曲", "天同", "廉貞",
                          "天府", "太陰", "貪狼", "巨門", "天相", "天梁",
                          "七殺", "破軍"]
        self.auxiliary_stars = ["文昌", "文曲", "左輔", "右弼", "天魁", "天鉞",
                               "禄存", "天馬", "化禄", "化権", "化科", "化忌"]
        self.inauspicious_stars = ["火星", "鈴星", "擎羊", "陀羅", "天刑", "天姚",
                                  "天哭", "天虚", "孤辰", "寡宿", "破碎", "蜚廉"]
        # 四化星のルール
        self.four_transformations = {
            "甲": ["廉貞化禄", "破軍化権", "武曲化科", "太陽化忌"],
            "乙": ["天機化禄", "天梁化権", "紫微化科", "太陰化忌"],
            "丙": ["天同化禄", "天機化権", "文昌化科", "廉貞化忌"],
            "丁": ["太陰化禄", "天同化権", "天機化科", "巨門化忌"],
            "戊": ["貪狼化禄", "太陰化権", "右弼化科", "天機化忌"],
            "己": ["武曲化禄", "貪狼化権", "天梁化科", "文曲化忌"],
            "庚": ["太陽化禄", "武曲化権", "太陰化科", "天同化忌"],
            "辛": ["巨門化禄", "太陽化権", "文曲化科", "文昌化忌"],
            "壬": ["天梁化禄", "紫微化権", "左輔化科", "武曲化忌"],
            "癸": ["破軍化禄", "巨門化権", "太陰化科", "貪狼化忌"]
        }
        # 宮位名と地支の対応関係
        self.palace_zhi_mapping = {
            "命宮": "子", "兄弟宮": "丑", "夫妻宮": "寅", "子女宮": "卯",
            "財帛宮": "辰", "疾厄宮": "巳", "遷移宮": "午", "奴僕宮": "未",
            "官禄宮": "申", "田宅宮": "酉", "福徳宮": "戌", "父母宮": "亥"
        }
        # 地支と宮位名の逆対応
        self.zhi_palace_mapping = {v: k for k, v in self.palace_zhi_mapping.items()}
        # 天干の数値定義（紫微斗数の正統ルール）
        self.gan_values = {
            "甲": 1, "乙": 2, "丙": 3, "丁": 4, "戊": 5,
            "己": 1, "庚": 2, "辛": 3, "壬": 4, "癸": 5
        }
        # 地支の数値定義（紫微斗数の正統ルール）
        self.zhi_values = {
            "子": 1, "丑": 2, "寅": 3, "卯": 4, "辰": 5, "巳": 6,
            "午": 1, "未": 2, "申": 3, "酉": 4, "戌": 5, "亥": 6
        }
        # 12宮の順行順序（時計回り）
        self.palaces_clockwise = ["命宮", "兄弟宮", "夫妻宮", "子女宮", "財帛宮", "疾厄宮", 
                                "遷移宮", "奴僕宮", "官禄宮", "田宅宮", "福徳宮", "父母宮"]
        # 12宮の逆行順序（反時計回り）
        self.palaces_counterclockwise = ["命宮", "父母宮", "福徳宮", "田宅宮", "官禄宮", "奴僕宮", 
                                       "遷移宮", "疾厄宮", "財帛宮", "子女宮", "夫妻宮", "兄弟宮"]
        # 地支の順序（順行）
        self.zhi_clockwise = ["子", "丑", "寅", "卯", "辰", "巳", "午", "未", "申", "酉", "戌", "亥"]
        # 地支の順序（逆行）
        self.zhi_counterclockwise = ["子", "亥", "戌", "酉", "申", "未", "午", "巳", "辰", "卯", "寅", "丑"]
        print("SUCCESS: ZiWeiDouShuIntermediate initialized successfully")
    
    def _normalize_palace_name(self, palace: str) -> str:
        """宮位名を正規化（強化版）"""
        if not palace:
            return palace
        # 地支を含む場合の処理（例: "午宮" → "命宮"）
        if any(zhi in palace for zhi in self.zhi_values.keys()):
            # 地支から宮位名を取得
            for zhi in self.zhi_values.keys():
                if zhi in palace:
                    return self.zhi_palace_mapping.get(zhi, palace)
        palace = palace.replace("徳", "徳").replace(" ", "").strip()
        palace_mapping = {
            "福徳宮": "福徳宮", "福徳": "福徳宮", "福徳": "福徳宮",
            "福徳宮位": "福徳宮", "福徳宮位": "福徳宮", "兄弟": "兄弟宮",
            "夫妻": "夫妻宮", "子女": "子女宮", "財帛": "財帛宮",
            "疾厄": "疾厄宮", "遷移": "遷移宮", "奴僕": "奴僕宮",
            "官禄": "官禄宮", "田宅": "田宅宮", "父母": "父母宮",
            "命": "命宮"
        }
        return palace_mapping.get(palace, palace)
    
    def _get_zhi_from_palace(self, palace_name: str) -> str:
        """宮位名から地支を抽出"""
        # 宮位名から地支を取得
        for palace, zhi in self.palace_zhi_mapping.items():
            if palace_name == palace:
                return zhi
        # 地支を直接抽出（例: "午宮" → "午"）
        for zhi in self.zhi_values.keys():
            if zhi in palace_name:
                return zhi
        # デフォルト（通常は発生しない）
        return "子"
    
    def _get_palace_from_zhi(self, zhi: str) -> str:
        """地支から宮位名を取得"""
        return self.zhi_palace_mapping.get(zhi, f"{zhi}宮")
    
    def _load_palace_stars_from_sheet(self, excel_file: str, sheet_name: str) -> Dict:
        """命盤シートから12宮の星配置を読み込む"""
        print(f"INFO: Loading palace stars from sheet: {sheet_name}")
        try:
            wb = openpyxl.load_workbook(excel_file)
            if sheet_name not in wb.sheetnames:
                raise ValueError(f"命盤シート '{sheet_name}' が見つかりません")
            sheet = wb[sheet_name]
            palace_stars = {}
            for row in sheet.iter_rows(min_row=2, values_only=True):
                if row and row[0]:
                    palace = str(row[0]).strip()
                    normalized_palace = self._normalize_palace_name(palace)
                    main_stars = row[1].split(', ') if row[1] and row[1] != "nan" else []
                    four_trans = row[2].split(', ') if row[2] and row[2] != "nan" else []
                    auxiliary = row[3].split(', ') if row[3] and row[3] != "nan" else []
                    inauspicious = row[4].split(', ') if row[4] and row[4] != "nan" else []
                    stars = main_stars + four_trans + auxiliary + inauspicious
                    palace_stars[normalized_palace] = stars
            print(f"SUCCESS: Palace stars loaded from sheet '{sheet_name}'")
            return palace_stars
        except Exception as e:
            print(f"ERROR: Failed to load palace stars: {str(e)}")
            raise
    
    def load_chart_from_excel(self, excel_file: str) -> Dict:
        """Excelから命盤情報と相性データを一括読み込み"""
        print(f"INFO: Loading chart data from Excel file: {excel_file}")
        try:
            # ユーザー基本情報シートの読み込み
            user_info = self._load_chart_from_sheet(excel_file, "ユーザー基本情報")
            # パートナー情報シートの検出
            wb = openpyxl.load_workbook(excel_file, read_only=True)
            partner_sheets = [s for s in wb.sheetnames if "パートナー" in s and "情報" in s]
            if not partner_sheets:
                raise ValueError("パートナー情報シートが見つかりません")
            partner_sheet_name = partner_sheets[0]
            partner_info = self._load_chart_from_sheet(excel_file, partner_sheet_name)
            # 関係性を抽出
            relationship = "パートナー"
            if "(" in partner_sheet_name and ")" in partner_sheet_name:
                relationship = partner_sheet_name.split("(")[1].split(")")[0]
            # ユーザー命盤シートの読み込み
            user_chart = self._load_palace_stars_from_sheet(excel_file, "ユーザー命盤")
            # パートナー命盤シートの読み込み
            partner_chart_name = f"パートナー({relationship})命盤"
            partner_chart = self._load_palace_stars_from_sheet(excel_file, partner_chart_name)
            result = {
                "user_info": user_info,
                "user_chart": user_chart,
                "partner_info": partner_info,
                "partner_chart": partner_chart,
                "relationship": relationship
            }
            print("SUCCESS: Chart data loaded successfully")
            return result
        except Exception as e:
            print(f"ERROR: Failed to load chart data: {str(e)}")
            raise
    
    def _load_chart_from_sheet(self, excel_file: str, sheet_name: str) -> Dict:
        """基本情報シートから情報を読み込む"""
        print(f"INFO: Loading chart from sheet: {sheet_name}")
        try:
            wb = openpyxl.load_workbook(excel_file)
            if sheet_name not in wb.sheetnames:
                raise ValueError(f"シート '{sheet_name}' が見つかりません")
            sheet = wb[sheet_name]
            person_info = {
                "name": None,
                "birth_info": {
                    "year": None, "month": None, "day": None,
                    "hour": None, "minute": None,
                    "year_gz": None, "month_gz": None
                },
                "solar_time": None,
                "lunar_date": None,
                "five_elements": None,
                "life_palace": None,
                "body_palace": None,
                "gender": None
            }
            for row in sheet.iter_rows(min_row=2, values_only=True):
                if row and row[0]:
                    key = row[0]
                    value = row[1] if len(row) > 1 else None
                    if key == "名前":
                        person_info["name"] = value
                    elif key == "生年月日" and value:
                        try:
                            date_str = str(value)
                            if match := re.search(r'(\d{4})年', date_str):
                                person_info["birth_info"]["year"] = int(match.group(1))
                            if match := re.search(r'(\d{1,2})月', date_str):
                                person_info["birth_info"]["month"] = int(match.group(1))
                            if match := re.search(r'(\d{1,2})日', date_str):
                                person_info["birth_info"]["day"] = int(match.group(1))
                            if match := re.search(r'(\d{1,2})時', date_str):
                                person_info["birth_info"]["hour"] = int(match.group(1))
                            if match := re.search(r'(\d{1,2})分', date_str):
                                person_info["birth_info"]["minute"] = int(match.group(1))
                        except Exception as e:
                            print(f"WARNING: Failed to parse birth date: {str(e)}")
                    elif key == "真太陽時":
                        person_info["solar_time"] = value
                    elif key == "旧暦日付":
                        person_info["lunar_date"] = value
                    elif key == "年干支":
                        person_info["birth_info"]["year_gz"] = value
                    elif key == "月干支":
                        person_info["birth_info"]["month_gz"] = value
                    elif key == "五行局":
                        person_info["five_elements"] = value
                    elif key == "命宮":
                        person_info["life_palace"] = self._normalize_palace_name(str(value))
                        # "宮"を含むか確認し、必要なら追加
                        if not person_info["life_palace"].endswith("宮"):
                            person_info["life_palace"] += "宮"
                    elif key == "身宮":
                        person_info["body_palace"] = self._normalize_palace_name(str(value))
                        # "宮"を含むか確認し、必要なら追加
                        if not person_info["body_palace"].endswith("宮"):
                            person_info["body_palace"] += "宮"
                    elif key == "性別":
                        person_info["gender"] = value
            # 必須項目の検証
            if not person_info.get("name"):
                raise ValueError("ユーザー名がありません")
            if not person_info.get("life_palace"):
                raise ValueError("命宮情報がありません")
            print(f"SUCCESS: Chart data loaded from sheet '{sheet_name}'")
            return person_info
        except Exception as e:
            print(f"ERROR: Failed to load chart: {str(e)}")
            raise
    
    def create_personality_prompt(self) -> Tuple[ChatPromptTemplate, JsonOutputParser]:
        """性格分析プロンプトを作成"""
        system_template = """あなたは優秀な紫微斗数専門家です。以下の情報を基に、JSON形式で詳細な占い結果を出力してください。"""
        human_template = """### ユーザー情報:
名前: {name}
生年月日: {year}年{month}月{day}日 {hour}時{minute}分
出生地: {place}
性別: {gender}
五行局: {five_elements}
命宮: {life_palace}宮
身宮: {shen_gong}宮
### 命盤情報:
命宮: {ming_gong_stars}
兄弟宮: {xiong_di_gong_stars}
夫妻宮: {fu_qi_gong_stars}
子女宮: {zi_nu_gong_stars}
財帛宮: {cai_bo_gong_stars}
疾厄宮: {ji_e_gong_stars}
遷移宮: {qian_yi_gong_stars}
奴僕宮: {nu_pu_gong_stars}
官禄宮: {guan_lu_gong_stars}
田宅宮: {tian_zhai_gong_stars}
福徳宮: {fu_de_gong_stars}
父母宮: {fu_mu_gong_stars}
### 指示:
紫微斗数の正統な手順と考え方に基づき、以下のJSON形式で結果を出力してください。
### JSON形式:
{{
  "personality": "性格分析（150-200文字）",
  "relation": "人間関係分析（150-200文字）",
  "capability_skills": {{
    "ratings": [
      {{"job": "教師", "rating": 1-5, "reason": "根拠"}},
      {{"job": "科学者", "rating": 1-5, "reason": "根拠"}},
      {{"job": "宗教家", "rating": 1-5, "reason": "根拠"}},
      {{"job": "事務員", "rating": 1-5, "reason": "根拠"}},
      {{"job": "芸術家", "rating": 1-5, "reason": "根拠"}},
      {{"job": "芸能人", "rating": 1-5, "reason": "根拠"}},
      {{"job": "経営者", "rating": 1-5, "reason": "根拠"}},
      {{"job": "政治家", "rating": 1-5, "reason": "根拠"}}
    ]
  }},
  "travel": "移動・移住に関する運勢（150-200文字）",
  "money": "金銭管理・投資適性（150-200文字）",
  "summary": "人生の主要テーマ（250-300文字）"
}}
"""
        system_message_prompt = SystemMessagePromptTemplate.from_template(system_template)
        human_message_prompt = HumanMessagePromptTemplate.from_template(human_template)
        prompt = ChatPromptTemplate.from_messages([system_message_prompt, hu-man_message_prompt])
        output_parser = JsonOutputParser()
        return prompt, output_parser
    
    def analyze_personality(self, chart_data: Dict, user_info: Dict) -> Dict:
        """性格分析を実行"""
        print(f"INFO: Starting personality analysis for {user_info['name']}")
        try:
            prompt, parser = self.create_personality_prompt()
            llm = ChatOpenAI(
                model="deepseek-reasoner",
                api_key=os.getenv("DEEPSEEK_API_KEY"),
                base_url="https://api.deepseek.com",
                temperature=0.3
            )
            chain = prompt | llm | parser
            result = chain.invoke({
                "name": user_info['name'],
                "year": user_info['birth_info']['year'],
                "month": user_info['birth_info']['month'] or 1,
                "day": user_info['birth_info']['day'] or 1,
                "hour": user_info['birth_info']['hour'] or 0,
                "minute": user_info['birth_info']['minute'] or 0,
                "place": "東京",
                "gender": user_info['gender'],
                "five_elements": user_info['five_elements'],
                "life_palace": user_info['life_palace'].replace("宮", ""),
                "shen_gong": user_info['body_palace'].replace("宮", ""),
                "ming_gong_stars": ", ".join(chart_data.get("命宮", [])),
                "xiong_di_gong_stars": ", ".join(chart_data.get("兄弟宮", [])),
                "fu_qi_gong_stars": ", ".join(chart_data.get("夫妻宮", [])),
                "zi_nu_gong_stars": ", ".join(chart_data.get("子女宮", [])),
                "cai_bo_gong_stars": ", ".join(chart_data.get("財帛宮", [])),
                "ji_e_gong_stars": ", ".join(chart_data.get("疾厄宮", [])),
                "qian_yi_gong_stars": ", ".join(chart_data.get("遷移宮", [])),
                "nu_pu_gong_stars": ", ".join(chart_data.get("奴僕宮", [])),
                "guan_lu_gong_stars": ", ".join(chart_data.get("官禄宮", [])),
                "tian_zhai_gong_stars": ", ".join(chart_data.get("田宅宮", [])),
                "fu_de_gong_stars": ", ".join(chart_data.get("福徳宮", [])),
                "fu_mu_gong_stars": ", ".join(chart_data.get("父母宮", []))
            })
            print(f"SUCCESS: Personality analysis completed")
            return result
        except Exception as e:
            print(f"ERROR: Personality analysis failed: {str(e)}")
            raise
    
    def generate_fortune_list(self, chart_data: Dict, user_info: Dict, fortune_years: List[int]) -> List[Dict]:
        """運勢年のリストを生成（大限・小限の表記を正統なルールに基づいて修正）"""
        print(f"INFO: Generating fortune list for {user_info['name']}")
        try:
            fortune_list = []
            birth_year = user_info['birth_info']['year']
            birth_year_gz = user_info['birth_info']['year_gz']
            birth_year_gan = birth_year_gz[0] if birth_year_gz else None
            gender = user_info['gender']
            # 命宮の処理
            life_palace = user_info['life_palace']
            # 命宮の地支を取得
            life_palace_zhi = self._get_zhi_from_palace(life_palace)
            print(f"DEBUG: 命宮={life_palace}, 地支={life_palace_zhi}")
            
            # 命宮の天干を五虎遁の法則で計算
            if birth_year_gan:
                if birth_year_gan in ["甲", "己"]:
                    base_gan = "丙"
                elif birth_year_gan in ["乙", "庚"]:
                    base_gan = "戊"
                elif birth_year_gan in ["丙", "辛"]:
                    base_gan = "庚"
                elif birth_year_gan in ["丁", "壬"]:
                    base_gan = "壬"
                else:  # ["戊", "癸"]
                    base_gan = "甲"
                # 寅宮を基準にした天干のオフセットを計算
                tiger_index = 2  # 寅は0-basedで2
                zhi_list = self.zhi_clockwise
                life_zhi_index = zhi_list.index(life_palace_zhi)
                # 地支の位置差を計算（寅からのオフセット）
                offset = (life_zhi_index - tiger_index) % 12
                # 天干のリストを取得
                gan_list = list(self.gan_values.keys())
                base_gan_index = gan_list.index(base_gan)
                # 命宮の天干を計算
                life_palace_gan = gan_list[(base_gan_index + offset) % 10]
            else:
                life_palace_gan = "甲"  # デフォルト値
            print(f"DEBUG: 命宮天干={life_palace_gan} (年干={birth_year_gan})")
            
            # 天干と地支の数値を取得
            gan_value = self.gan_values.get(life_palace_gan, 1)
            zhi_value = self.zhi_values.get(life_palace_zhi, 1)
            # 大限の開始年齢を計算 (天干の数値 + 地支の数値)
            major_period_start_age = gan_value + zhi_value
            print(f"DEBUG: 大限開始年齢={major_period_start_age}歳 (天干値={gan_value} + 地支値={zhi_value})")
            
            # 大限の進行方向を決定（男性は順行、女性は逆行）
            if gender == "男性":
                zhi_sequence = self.zhi_clockwise
                print("DEBUG: 大限進行方向: 順行(男性)")
            else:  # 女性
                zhi_sequence = self.zhi_counterclockwise
                print("DEBUG: 大限進行方向: 逆行(女性)")
            
            # 命宮の地支のインデックスを取得
            start_index = zhi_sequence.index(life_palace_zhi)
            print(f"DEBUG: 命宮地支開始インデックス={start_index} (地支={life_palace_zhi})")
            
            for year in fortune_years:
                age = year - birth_year
                # 大限の計算
                if age < major_period_start_age:
                    major_period = "未開始"
                else:
                    # 現在の大限を計算
                    period_index = (age - major_period_start_age) // 10
                    major_period_age = major_period_start_age + period_index * 10
                    # 宮位をループさせる
                    palace_zhi_index = (start_index + period_index) % 12
                    palace_zhi = zhi_sequence[palace_zhi_index]
                    major_palace = self._get_palace_from_zhi(palace_zhi)
                    major_period = f"{major_period_age}～{major_period_age+9}歳の大限は{major_palace}"
                
                # 小限の計算 (三合派では男女ともに順行)
                if age < 1:
                    minor_period = "未開始"
                else:
                    # 小限は命宮の位置から始まり、1年ごとに順行
                    minor_zhi_index = (zhi_sequence.index(life_palace_zhi) + (age - 1)) % 12
                    minor_zhi = zhi_sequence[minor_zhi_index]
                    minor_palace = self._get_palace_from_zhi(minor_zhi)
                    minor_period = f"{age}歳の小限は{minor_palace}"
                
                # 流年干支の取得
                annual_gz = self.calculate_annual_gz(year)
                # 年齢に基づく流曜の計算
                age_mod_12 = age % 12
                annual_stars = self.calculate_annual_stars(age_mod_12, birth_year_gan)
                
                fortune_list.append({
                    "year": year,
                    "age": age,
                    "major_period": major_period,
                    "minor_period": minor_period,
                    "annual_gz": annual_gz,
                    "annual_stars": annual_stars
                })
            print(f"SUCCESS: Fortune list generated for {len(fortune_list)} years")
            return fortune_list
        except Exception as e:
            print(f"ERROR: Failed to generate fortune list: {str(e)}")
            traceback.print_exc()
            raise
    
    def calculate_annual_gz(self, year: int) -> str:
        """流年干支を計算"""
        # 簡易実装（実際はもっと複雑な計算が必要）
        gan = ["甲", "乙", "丙", "丁", "戊", "己", "庚", "辛", "壬", "癸"]
        zhi = ["子", "丑", "寅", "卯", "辰", "巳", "午", "未", "申", "酉", "戌", "亥"]
        base_year = 1984  # 甲子年
        index = (year - base_year) % 60
        return gan[index % 10] + zhi[index % 12]
    
    def calculate_annual_stars(self, age_mod: int, birth_gan: str) -> List[str]:
        """流曜を計算"""
        # 簡易実装（実際はもっと複雑な計算が必要）
        stars = []
        if age_mod == 0: stars.append("青龍")
        if age_mod == 1: stars.append("小耗")
        if age_mod == 2: stars.append("将軍")
        if age_mod == 3: stars.append("奏書")
        if age_mod == 4: stars.append("飛廉")
        if age_mod == 5: stars.append("喜神")
        if age_mod == 6: stars.append("病符")
        if age_mod == 7: stars.append("大耗")
        if age_mod == 8: stars.append("伏兵")
        if age_mod == 9: stars.append("官府")
        if age_mod == 10: stars.append("歳建")
        if age_mod == 11: stars.append("晦気")
        return stars
    
    def export_to_excel(self, excel_file: str, chart_data: Dict, personality_result: Dict,
                      fortune_list: List[Dict], user_info: Dict, prefix: str = ""):
        """Excelファイルに中間結果を出力"""
        print(f"INFO: Exporting intermediate results to Excel")
        try:
            # 元ファイルをコピー
            output_file = excel_file.replace("前半結果", "中間結果")
            
            # ソースファイルと出力ファイルが異なる場合のみコピー
            if excel_file != output_file:
                shutil.copy2(excel_file, output_file)
            
            wb = openpyxl.load_workbook(output_file)
            # 性格分析シートの作成
            self._create_personality_analysis_sheet(wb, personality_result, prefix)
            # 職業適性シートの作成
            self._create_career_suitability_sheet(wb, personality_result, prefix)
            # 年別運勢シートの作成（LLM分析前）
            self._create_yearly_fortune_sheet(wb, fortune_list, prefix)
            # ファイルを保存
            wb.save(output_file)
            print(f"SUCCESS: Intermediate results exported to: {output_file}")
            return output_file
        except Exception as e:
            print(f"ERROR: Failed to export to Excel: {str(e)}")
            raise
    
    def _create_personality_analysis_sheet(self, wb, personality_result, prefix: str):
        """性格分析シートを作成"""
        sheet_name = f"{prefix}性格分析"
        if sheet_name in wb.sheetnames:
            del wb[sheet_name]
        sheet = wb.create_sheet(title=sheet_name)
        thin_border = Border(left=Side(style='thin'), right=Side(style='thin'),
                            top=Side(style='thin'), bottom=Side(style='thin'))
        headers = ["項目", "内容"]
        sheet.append(headers)
        data_rows = [
            ["性格特性", personality_result["personality"]],
            ["人間関係", personality_result["relation"]],
            ["移動・移住", personality_result["travel"]],
            ["金銭管理", personality_result["money"]],
            ["人生の主要テーマ", personality_result["summary"]]
        ]
        for row in data_rows:
            sheet.append(row)
        print(f"SUCCESS: Personality analysis sheet created")
    
    def _create_career_suitability_sheet(self, wb, personality_result, prefix: str):
        """職業適性シートを作成"""
        sheet_name = f"{prefix}職業適性"
        if sheet_name in wb.sheetnames:
            del wb[sheet_name]
        sheet = wb.create_sheet(title=sheet_name)
        headers = ["職業", "適性評価 (1-5)", "根拠"]
        sheet.append(headers)
        for rating in personality_result["capability_skills"]["ratings"]:
            sheet.append([rating["job"], rating["rating"], rating["reason"]])
        print(f"SUCCESS: Career suitability sheet created")
    
    def _create_yearly_fortune_sheet(self, wb, fortune_list, prefix: str):
        """年別運勢シートを作成（LLM分析前）"""
        sheet_name = f"{prefix}年別運勢"
        if sheet_name in wb.sheetnames:
            del wb[sheet_name]
        sheet = wb.create_sheet(title=sheet_name)
        headers = ["年", "大限", "小限", "干支", "流曜"]
        sheet.append(headers)
        for fortune in fortune_list:
            sheet.append([
                fortune["year"],
                fortune["major_period"],
                fortune["minor_period"],
                fortune["annual_gz"],
                ", ".join(fortune["annual_stars"])
            ])
        print(f"SUCCESS: Yearly fortune sheet created")
# ---
class IntermediateWorkflow:
    def __init__(self):
        print("INFO: Initializing IntermediateWorkflow...")
        self.ziwei = ZiWeiDouShuIntermediate()
        self.app = self._create_graph()
        print("SUCCESS: IntermediateWorkflow initialized")
    
    def _create_graph(self):
        workflow = StateGraph(dict)
        workflow.add_node("load_charts", self._load_charts)
        workflow.add_node("analyze_user", self._analyze_user)
        workflow.add_node("analyze_partner", self._analyze_partner)
        workflow.add_node("gen_user_fortune", self._gen_user_fortune)
        workflow.add_node("gen_partner_fortune", self._gen_partner_fortune)
        workflow.add_node("export_results", self._export_results)
        workflow.set_entry_point("load_charts")
        workflow.add_edge("load_charts", "analyze_user")
        workflow.add_edge("analyze_user", "analyze_partner")
        workflow.add_edge("analyze_partner", "gen_user_fortune")
        workflow.add_edge("gen_user_fortune", "gen_partner_fortune")
        workflow.add_edge("gen_partner_fortune", "export_results")
        workflow.add_edge("export_results", END)
        return workflow.compile()
    
    def _load_charts(self, state: dict) -> dict:
        state['chart_data'] = self.ziwei.load_chart_from_excel(state['excel_file'])
        return state
    
    def _analyze_user(self, state: dict) -> dict:
        chart_data = state['chart_data']
        state['user_personality'] = self.ziwei.analyze_personality(
            chart_data['user_chart'], chart_data['user_info'])
        return state
    
    def _analyze_partner(self, state: dict) -> dict:
        chart_data = state['chart_data']
        state['partner_personality'] = self.ziwei.analyze_personality(
            chart_data['partner_chart'], chart_data['partner_info'])
        return state
    
    def _gen_user_fortune(self, state: dict) -> dict:
        chart_data = state['chart_data']
        state['user_fortune_list'] = self.ziwei.generate_fortune_list(
            chart_data['user_chart'], chart_data['user_info'], state['fortune_years'])
        return state
    
    def _gen_partner_fortune(self, state: dict) -> dict:
        chart_data = state['chart_data']
        state['partner_fortune_list'] = self.ziwei.generate_fortune_list(
            chart_data['partner_chart'], chart_data['partner_info'], state['fortune_years'])
        return state
    
    def _export_results(self, state: dict) -> dict:
        chart_data = state['chart_data']
        output_file = self.ziwei.export_to_excel(
            state['excel_file'],
            chart_data['user_chart'],
            state['user_personality'],
            state['user_fortune_list'],
            chart_data['user_info'],
            "ユーザー_"
        )
        output_file = self.ziwei.export_to_excel(
            output_file,
            chart_data['partner_chart'],
            state['partner_personality'],
            state['partner_fortune_list'],
            chart_data['partner_info'],
            "パートナー_"
        )
        state['intermediate_file'] = output_file
        return state
    
    def run(self, excel_file: str, fortune_years: List[int]) -> Dict:
        initial_state = {"excel_file": excel_file, "fortune_years": fortune_years}
        return self.app.invoke(initial_state)

if __name__ == "__main__":
    excel_file = "/content/drive/MyDrive/石〇何某_天〇は反日_相性分析_前半結果.xlsx"
    fortune_years = [1995, 2000, 2009, 2011, 2013, 2015, 2020, 2022, 2025, 2026]
    print("\n" + "="*50)
    print("紫微斗数中間処理プログラムを開始します")
    print("="*50)
    try:
        workflow = IntermediateWorkflow()
        results = workflow.run(excel_file, fortune_years)
        print("\n" + "="*50)
        print("中間処理が正常に完了しました")
        print(f"中間ファイル: {results['intermediate_file']}")
        print("="*50)
    except Exception as e:
        print("\n" + "="*50)
        print(f"エラーが発生しました: {str(e)}")
        print("="*50)
        traceback.print_exc()

```

D先生： “うへえ・・・。確かに長いプログラムだな。今回は、処理進捗が見えているのでいいが、この仕組みがなければ、ちゃんと動いているのか不安になるレベルです。 “

![imageINDS1-19-3](/2025-07-31-QEUR23_INDHS28/imageINDS1-19-3.jpg) 

QEU:FOUNDER  ： “じゃあ、結果を一つづつ見てみましょうか・・・。まずは、お二人の性格を分析します。”

![imageINDS1-19-4](/2025-07-31-QEUR23_INDHS28/imageINDS1-19-4.jpg) 

D先生： “「なるほど」と納得する出来栄えです。それにしても、Aさんは、キャラが立っていますね。次は、職業適性ですね。どうなるかな？ “

![imageINDS1-19-5](/2025-07-31-QEUR23_INDHS28/imageINDS1-19-5.jpg) 

D先生：“I氏の政治家適正が5レベルまで行かない理由がわかりました。**「権力争い」**なんですね。ほぉ～・・・。これは、とても香ばしい。”

QEU:FOUNDER ： “さて、いよいよ運勢に行きます。D先生、初めに注意します。”

D先生：“なんですか？”

QEU:FOUNDER ： “腰を抜かさないように、イスにつかまっていてください。ドン！！”

![imageINDS1-19-6](/2025-07-31-QEUR23_INDHS28/imageINDS1-19-6.jpg) 

D先生：“「伏兵」！！イタタタッ・・・。腰が抜けてしまいました。伏兵は、具体的にどういう意味なんですか？”

紫微斗数における「流曜」の一つである「伏兵」は、流年（その年の運勢）において特定の影響を及ぼす星として解釈されます。「伏兵」は、文字通り「隠れた兵士」を意味し、予期せぬ出来事や潜在的な障害、裏での動きなどを暗示する星です。以下に、その運勢の特徴を簡潔に説明します。 

### 「伏兵」の運勢の暗示 

1. **隠れた問題や障害** 「伏兵」は、表面上は見えないところで問題や障害が潜んでいることを示します。流年にこの星が現れる場合、突然のトラブルや予期せぬ出来事に注意が必要です。特に、信頼していた人や状況が裏切る可能性や、隠されたリスクが表面化する可能性があります。 

2. **裏での動きや陰謀** この星は、他人からの嫉妬、陰謀、または秘密裏の計画が進行していることを示唆することがあります。対人関係では、信頼していた人物が裏で異なる行動を取る可能性や、誤解や噂によるトラブルに警戒が必要です。 

3. **慎重な行動が必要** 「伏兵」が流年に現れる場合、軽率な行動や判断は避け、慎重に物事を進めるべき時期です。契約、投資、人間関係など、重要な決断を下す際は、裏に隠れたリスクがないか十分に確認することが求められます。 

4. **健康面の注意** 健康面では、潜在的な不調や見過ごしていた症状が表面化する可能性があります。定期的な健康チェックや体調管理を怠らないことが重要です。 

5. **吉凶のバランス** 「伏兵」自体は凶星とされることが多いですが、他の流曜や本命盤・流年盤の配置との組み合わせによって影響が変化します。たとえば、吉星（例：天魁、天鉞、禄存など）と一緒であれば、問題があっても解決の糸口が見つかりやすい場合があります。逆に、凶星（例：陀羅、鈴星など）と重なると、トラブルがより顕著になる可能性があります。 

### 対処法 

- **情報収集と慎重な判断**：重要な決定を下す前に、十分な情報収集を行い、急がず慎重に進める。 - **対人関係の注意**：信頼関係を見直し、裏切りや誤解を防ぐためにコミュニケーションを明確にする。 - **リスク管理**：仕事や投資では、リスクを最小限に抑える計画を立てる。 
- **健康管理**：体調の変化に敏感になり、早めに対処する。 

### 補足 

「伏兵」の影響は、流年盤のどの宮（命宮、財帛宮、事業宮など）に現れるかによっても異なります。たとえば、命宮に現れる場合は人生全般に影響し、財帛宮なら金銭面、夫妻宮ならパートナーシップに関連する問題が強調される可能性があります。また、個人の本命盤や大限・小限の状況も総合的に考慮する必要があります。 もし具体的な流年盤や本命盤の配置を教えていただければ、より詳細な解釈が可能です！また、紫微斗数の流曜は複雑な相互作用を持つため、専門の占師に相談するのも一つの手です。

QEU:FOUNDER ： “やっぱりねえ。他の「流曜」の意味は、自分で調べてください。”

D先生：“すごいなあ・・・。このプログラム・・・。”

QEU:FOUNDER ： “いやあ、これは**失敗作**だよ。”

D先生：“どういう意味ですか？”

QEU:FOUNDER ： “つづく、「まとめ」で議論しましょう。”


## ～ まとめ ～

D先生：“さて、本プログラムが失敗作だという意味ですが・・・。”

QEU:FOUNDER ： “要件定義書の製作で七転八倒したんです。まあ、しようがないんです。我々は、紫微斗数のことを全く知らないんだから。何はともあれ、要件定義書を晒しておきます。”

# 紫微斗数分析_中間処理用プログラム 要件定義書 

## 1. 入力EXCELファイルの内容
プログラムが読み込む入力Excelファイルのシート構成と内容を以下に示します：
### 基本情報シート
- **ユーザー基本情報**：
  - 名前、生年月日、出生時間、出生地、性別
  - 真太陽時、旧暦日付、年干支、月干支
  - 命宮・身宮の位置、五行局
  - *例: 命宮が"午宮"の場合、データ内では"午"として格納*
  - *更新点: 前半処理で作成された情報であり、中間処理では読み取り専用*
- **パートナー(関係性)情報**：
  - ユーザーと同様の基本情報（パートナーのデータ）
  - シート名の括弧内にパートナー関係を明記（例：パートナー(同僚)情報）
  - *注：関係性はシート名から自動抽出される*
  - *更新点: シート名の形式が「パートナー(関係性)情報」であることを厳密にチェック*
  - *更新点: 前半処理で作成された情報であり、中間処理では読み取り専用*
### 命盤シート
- **ユーザー命盤**：
  - 12宮（命宮/兄弟宮/夫妻宮/子女宮/財帛宮/疾厄宮/遷移宮/奴僕宮/官禄宮/田宅宮/福徳宮/父母宮）
  - 各宮の主星・四化星・補助星・凶星の配置（4列構造）
  - *更新点: "nan"値や空文字列の処理を実装（データ欠落時の対応）*
  - *更新点: 前半処理で作成された情報であり、中間処理では読み取り専用*
- **パートナー(関係性)命盤**：
  - ユーザー命盤と同形式のパートナー命盤データ
  - シート名は"パートナー(関係性)情報"と一致する関係性を含む
  - *更新点: シート名から自動的に"命盤"シート名を生成*
  - *更新点: 前半処理で作成された情報であり、中間処理では読み取り専用*
### 相性分析シート
- **(関係性)相性分析**：
  - ユーザーとパートナーの関係性に基づく総合評価
  - 相性の強み・課題・具体的なアドバイス
  - *例：同僚相性分析、夫婦相性分析など*
  - *更新点: プログラムはこのシートを読み込むが、上書きや修正は行わない*
  - *更新点: 前半処理で作成された情報であり、中間処理では読み取り専用*

## 2. 紫微斗数占いの全体プロセスと本プログラムの位置づけ
### 全体プロセス
紫微斗数占いは以下の3段階で構成されます：
1. **前半プロセス**：
   - ユーザーとパートナーの生年月日・出生時刻・出生地から
   - 命盤の作成（12宮への星配置の計算）
   - 五行局・命宮・身宮の特定
   - Excel形式の命盤データの出力
   - *出力ファイル名例: `石〇何某_天〇は反日_相性分析_前半結果.xlsx`*
2. **中間プロセス**（本プログラム）：
   - 前半プロセスで作成されたExcel命盤データを入力する
   - 星配置に基づく中間分析を実施する
   - LLMを活用した性格、職業適性を分析する
   - 運勢年リスト（例：[2000, 2005, 2009, ...]）から流年情報を計算し、表形式でまとめる
   - 中間分析結果のExcelへの出力
   - *出力ファイル名例: `石〇何某_天〇は反日_相性分析_中間結果.xlsx`*
3. **最終プロセス**：
   - 前半プロセスで作成されたExcel命盤データと中間プロセスで作成された情報（流年など）を結合したExcelデータを入力する
   - 年運の詳細分析と運勢グラフの作成
   - 人間関係の相性推移分析
   - 総合的な運勢診断とアドバイスの作成
   - *出力ファイル名例: `石〇何某_天〇は反日_相性分析_最終結果.xlsx`*
### 本プログラムの特徴
- **LLMの戦略的活用**：
  - `deepseek-reasoner`：性格分析・職業適性診断（推論を使った思考力重視）
  - *更新点: APIキーとベースURLが環境変数から取得される仕様に変更*
- **LangGraphによるワークフロー管理**：
  - 分析プロセスをノード化し、拡張性を確保
  - ユーザー/パートナーの分析を並行処理
  - *更新点: ワークフローグラフのノード構造が明確に定義されている*
  - *追加: 実行順序は「load_charts → analyze_user → analyze_partner → gen_user_fortune → gen_partner_fortune → export_results」*
- **正統な紫微斗数の解釈**：
  - 星の配置と12宮の意味に基づく正統な分析
  - 四化星・流曜の影響を考慮した、流年の正統な運勢リストの作成する
  - *更新点: 大限開始年齢の計算が命宮の天干と地支の数値合計に基づいて厳密に行われる*
  - *追加: 命宮の天干は「五虎遁」という方法で計算される*

## 3. クラスと関数の機能説明
### ZiWeiDouShuIntermediate クラス
#### 星の分類
| 分類 | 星一覧 |
|------|--------|
| **主要星** | 紫微, 天機, 太陽, 武曲, 天同, 廉貞, 天府, 太陰, 貪狼, 巨門, 天相, 天梁, 七殺, 破軍 |
| **補助星** | 文昌, 文曲, 左輔, 右弼, 天魁, 天鉞, 禄存, 天馬, 化禄, 化権, 化科, 化忌 |
| **凶星** | 火星, 鈴星, 擎羊, 陀羅, 天刑, 天姚, 天哭, 天虚, 孤辰, 寡宿, 破碎, 蜚廉 |
| クラス/メソッド | 機能概要 | 更新点 |
|----------------|----------|--------|
| **コンストラクタ** | 108星の分類と12宮の定義、四化星ルールの設定、大限開始年齢の設定 | 108星の分類を主要星・補助星・凶星の3分類に整理 |
| `load_chart_from_excel` | Excelから命盤情報と相性データを一括読み込み | シート名のパターンマッチングを改善、エラーハンドリングを強化 |
| `_load_chart_from_sheet` | 基本情報シートから個人情報を抽出（名前・生年月日等） | "nan"値の処理を実装、必須項目の検証を追加 |
| `_load_palace_stars_from_sheet` | 命盤シートから12宮の星配置を辞書形式で取得 | 空値や"nan"の適切な処理を実装、宮位名の正規化機能を追加 |
| `_normalize_palace_name` | 宮位名の正規化（例："福徳"→"福徳宮"） | 宮位名の一貫性を保つための追加機能、宮位名と地支の対応を考慮 |
| `create_personality_prompt` | 性格分析用プロンプトのテンプレート作成（JSON出力形式指定） | 出力形式を厳密に定義、評価基準を明確化 |
| `analyze_personality` | LLMを用いた性格・適職・人生テーマの分析実行 | deepseek-reasonerモデルを明示的に指定、出力結果の検証機能を追加 |
| `generate_fortune_list` | 運勢年リストの生成（大限・小限・干支・流曜の計算） | **全面修正**: 大限開始年齢を天干・地支の数値合計で計算。男性は順行、女性は逆行で大限を進行。大限表記を"年齢範囲 + の大限は + 宮位"の形式に変更（例: "32～41歳の大限は財帛宮"）。小限表記を"年齢 + の小限は + 宮位"の形式に変更（例: "35歳の小限は夫妻宮"）。宮位名と地支の対応を正しく反映。**大限と小限の計算に命宮の実際の位置を正しく反映**。|
| `calculate_annual_gz` | 流年干支を計算 | 簡易実装（実際はもっと複雑な計算が必要） |
| `calculate_annual_stars` | 流曜を計算 | 簡易実装（実際はもっと複雑な計算が必要） |
| `export_to_excel` | 分析結果をExcelに追加出力する統合インターフェース | 既存シートの削除処理を追加、プレフィックス付きシート名の管理を改善 |
| `_create_personality_analysis_sheet` | 性格分析シートの作成（罫線・折り返し等の書式設定） | 必須項目の検証を追加、エラーハンドリングを強化 |
| `_create_career_suitability_sheet` | 職業適性シートの作成（8職種の評価と理由） | 理由欄の折り返し表示を強制、日本語フォント対応を強化 |
| `_create_yearly_fortune_sheet` | 年別運勢シートの作成（大限・小限・干支・流曜） | **更新点**: 本プログラムの主要出力、スコアなしの基礎データを出力。**カラム構成は「年, 大限, 小限, 干支, 流曜」** |

### IntermediateWorkflow クラス
| クラス/メソッド | 機能概要 | 更新点 |
|----------------|----------|--------|
| **コンストラクタ** | LangGraphワークフローの初期化 | ワークフローグラフのノードとエッジを厳密に定義 |
| `_create_graph` | 分析ワークフローのグラフ定義（ノードとエッジの設定） | **大幅更新**: 6つの処理ノードを定義、エッジ接続を明確化、**実行順序を「load_charts → analyze_user → ana-lyze_partner → gen_user_fortune → gen_partner_fortune → export_results」に固定** |
| `_load_charts` | 入力Excelからデータを読み込み状態に格納 | 関係性の抽出ロジックを改善、エラーハンドリングを追加 |
| `_analyze_user` | ユーザーの性格分析を実行 | 状態管理を実装、処理の追跡を可能に |
| `_analyze_partner` | パートナーの性格分析を実行 | ユーザー分析と独立した処理フローを確保 |
| `_gen_user_fortune` | ユーザーの運勢年リストを生成 | 運勢年の計算ロジックを厳密に実装、**大限と小限の計算に命宮の実際の位置を正しく反映** |
| `_gen_partner_fortune` | パートナーの運勢年リストを生成 | ユーザーと独立した計算を実施、**大限と小限の計算に命宮の実際の位置を正しく反映** |
| `_export_results` | 分析結果をExcelに書き出し（"_中間結果"をファイル名に追加） | **更新**: "前半結果"を"中間結果"に置換するロジックを改善、ファイルコピー処理を追加 |
| `run` | ワークフローの実行エントリーポイント | 完了メッセージを詳細化、エラートレースを出力 |

## 4. 出力ファイルの種類と命名規則
### Excel出力ファイル
- **命名規則**：
  - 入力ファイル名に"_中間結果"を追加
  - 例: `石〇何某_天〇は反日_相性分析_前半結果.xlsx` → `石〇何某_天〇は反日_相性分析_中間結果.xlsx`
  - "前半結果"を含む場合は"_中間結果"に置換
  - *更新点: 出力前に元ファイルをコピーする仕様に変更*
- **新規追加シート**：
  | シート名 | 内容 | 重複回避のための注意点 |
  |----------|------|----------------------|
  | ユーザー_性格分析 | 性格特性・人間関係・人生テーマの分析結果 | パートナー分析と区別するため"ユーザー_"プレフィックスを付与 |
  | ユーザー_職業適性 | 8職種の適性評価（1-5段階）と根拠 | プレフィックスでユーザー/パートナーを区別 |
  | ユーザー_年別運勢 | 指定年の大限・小限・干支・流曜情報 | プレフィックスでユーザー/パートナーを区別、**カラム構成は「年, 大限, 小限, 干支, 流曜」**、スコアなしの基礎データ |
  | パートナー_性格分析 | パートナーの性格分析結果 | ユーザー分析と別シートで管理 |
  | パートナー_職業適性 | パートナーの職業適性評価 | ユーザー分析と別シートで管理 |
  | パートナー_年別運勢 | パートナーの年運基礎データ | ユーザー分析と別シートで管理、**カラム構成は「年, 大限, 小限, 干支, 流曜」**、スコアなしの基礎データ |
  - *更新点: 既存の分析シートがある場合は削除してから新規作成*

## 5. 出力用EXCELファイルのタブの名前と構成
### タブ構成と内容
| シート名 | 内容 | 機能 |
|----------|------|------|
| ユーザー基本情報 | ユーザーの基本情報（名前、生年月日等） | 前半処理で作成、中間処理で参照 |
| パートナー(同僚)情報 | パートナーの基本情報（名前、生年月日等） | 前半処理で作成、中間処理で参照 |
| ユーザー命盤 | ユーザーの12宮の星配置データ | 前半処理で作成、中間処理で参照 |
| パートナー(同僚)命盤 | パートナーの12宮の星配置データ | 前半処理で作成、中間処理で参照 |
| 同僚相性分析 | ユーザーとパートナーの相性評価 | 前半処理で作成、中間処理で参照 |
| ユーザー_性格分析 | LLMによる性格分析結果 | **中間処理で新規作成**、性格特性・人間関係・人生テーマ |
| ユーザー_職業適性 | 8職種の適性評価と根拠 | **中間処理で新規作成**、1-5段階評価 |
| ユーザー_年別運勢 | 大限・小限・干支・流曜の基礎データ | **中間処理で新規作成**、**カラム構成は「年, 大限, 小限, 干支, 流曜」**、スコアなしの基礎情報 |
| パートナー_性格分析 | パートナーの性格分析結果 | **中間処理で新規作成**、性格特性・人間関係・人生テーマ |
| パートナー_職業適性 | パートナーの8職種適性評価 | **中間処理で新規作成**、1-5段階評価 |
| パートナー_年別運勢 | パートナーの大限・小限・干支・流曜 | **中間処理で新規作成**、**カラム構成は「年, 大限, 小限, 干支, 流曜」**、スコアなしの基礎情報 |

### 重複回避のための注意点
- **プレフィックスの厳格な使用**: "ユーザー_"と"パートナー_"のプレフィックスを必ず使用し、同じ種類のシートを区別
- **スコアの有無による区別**: 中間処理では年別運勢にスコアを含めず、最終処理でスコアを追加
- **処理段階の明確化**: 前半処理で作成されたシートは編集せず、中間処理で新規作成するシートのみを追加
- **シート名の統一ルール**: 全ての新規シート名に"_特性"を含め、機能を明確に識別可能に

## 6. プロンプトが期待する機能分析
#### 性格分析プロンプトが期待する機能：
```json
{
  "personality": "主星配置などから性格特性を分析する（150-200文字）",
  "relation": "人間関係の傾向（兄弟宮・夫妻宮の星配置など）（150-200文字）",
  "capability_skills": {
    "ratings": [
      {"job": "職業分野", "rating": 1-5, "reason": "星配置などに基づく根拠"}
    ]
  },
  "travel": "移動・移住に関する運勢（遷移宮の星配置などに基づく根拠）（150-200文字）",
  "money": "金銭管理・投資適性（財帛宮の星配置などに基づく根拠）（150-200文字）",
  "summary": "人生の主要テーマ（命宮・身宮の意味などから総合的に解釈する）（250-300文字）"
}
```
- *更新点: 評価対象の職業は8種類に固定（教師・科学者・宗教家・事務員・芸術家・芸能人・経営者・政治家）*
- *更新点: 文字数制限を厳密に指定、最終処理との役割分担を明確化*

## 7. 追加要件仕様
1. **日本語フォント対応**：
   - matplotlibで日本語表示するための自動フォント検出機能を実装
   - 優先フォントリスト（Hiragino系、Meiryo、Noto系など）から利用可能なフォントを選択
   - フォントテスト描画で正常動作を確認
   - *更新点: 中間処理ではグラフ出力を行わないため、フォント対応は最終処理に移管*
2. **エラーハンドリングとログ**：
   - 各主要処理ステップでINFO/DEBUG/SUCCESS/ERRORメッセージを出力
   - エラー発生時は詳細なエラーメッセージとトレースを出力
   - 必須項目の検証を厳密に行い、欠落時は明確なエラーメッセージを表示
3. **データ検証**：
   - Excelファイルの必須シートの存在確認
   - 必須項目（名前、生年月日、命宮など）の存在確認
   - 星配置データの整合性チェック
4. **運勢計算の正確性**：
   - 大限の開始年齢を命宮の天干と地支の数値の合計で計算する
   - **天干の数値**：
     - 甲、己：1
     - 乙、庚：2
     - 丙、辛：3
     - 丁、壬：4
     - 戊、癸：5
   - **地支の数値**：
     - 子、午：1
     - 丑、未：2
     - 寅、申：3
     - 卯、酉：4
     - 辰、戌：5
     - 巳、亥：6
   - 例：命宮が「甲子」なら、1+1=2歳から最初の10年（2～11歳）が始まる
   - 男性は順行（時計回り）、女性は逆行（反時計回り）で大限が進行
   - 大限の表記は"年齢範囲 + の大限は + 宮位"の形式で行う（例: "32～41歳の大限は財帛宮"）
   - **小限は命宮の位置から始まり、1年ごとに順行する**（三合派に基づき、男女ともに順行）
   - 小限の表記は"年齢 + の小限は + 宮位"の形式で行う（例: "35歳の小限は夫妻宮"）
   - 大限・小限の宮位を正しく計算し、表記に反映
   - 流曜の計算は、生年干支と流年干支を考慮した正統な方法で行う
   - 宮位名と地支の対応関係を明確に定義し、正しく参照する
   - 大限の進行方向（男性は順行、女性は逆行）を正しく反映する
   - **命宮の天干は「五虎遁」という方法で計算する**
   - **大限の計算では命宮の実際の位置を正しく考慮する**
   - **小限の計算では命宮の実際の位置を正しく考慮する**
5. **ファイル処理**：
   - 出力前に元ファイルをコピーしてから追加情報を書き込む
   - "前半結果"を含むファイル名は"中間結果"に置換
   - *更新点: グラフ出力は行わない（最終処理に移管）*
6. **処理フロー**：
   - LangGraphを用いたワークフローで処理ステップを明確に可視化
   - ユーザー分析とパートナー分析を並行して実行可能
   - 状態管理により処理の追跡とデバッグを容易に
   - **実行順序は「load_charts → analyze_user → analyze_partner → gen_user_fortune → gen_partner_fortune → export_results」に固定**
7. **その他**：
   - 紫微斗数の占い精度が向上するのであれば、命盤・流年計算とLLM推論手法に関連するロジックに限り、上記の仕様にこだわらない
   - *更新点: 評点スコアは最終処理で実施するため、中間処理ではスコアなしの基礎データを出力*
   - 身宮の情報は、ユーザー（及びパートナー）基本情報から直接取得
   - 星の名称は日本語の漢字表記を原則とする（中国発祥の占いだが、日本語環境に適合）
   - 出力ファイル名は"_中間結果"を追加または"前半結果"を置換
   - プログラム実行の各ステップで進行状況をログ出力し、正常終了/異常終了を明確に示す
   - *更新点: 中間処理では分析結果の基礎データを作成し、最終処理で詳細分析を行う役割分担を明確化*

QEU:FOUNDER ： “七転八倒の結果として、たまたまに**うまく見えるプログラムが出来ている**ようです。しかし、この要件定義書が「正統なもの」かどうかは分からないんです。恐らく、相当に流派が「混ぜこじゃ」になっているんじゃないんですかねえ・・・。”

D先生：“Vibe Codingでは要件定義書を必ず添えるようにしているんでしょう?クチャぐちゃになるんですか？”

QEU:FOUNDER ： “これが、面白くてねえ・・・。要件定義書を添えて、さらに冒頭の指示で「これをやって・・・」というでしょ？そうするとねえ、なんとLLMは、要件定義書の言う通りにコードを変えちゃうんです。それを知らなかったから、途中でコードがクチャぐちゃになって、わけがわからなくなりました・・・（笑）。”

[![MOVIE1](http://img.youtube.com/vi/Xr-g3eIM9do/0.jpg)](http://www.youtube.com/watch?v=Xr-g3eIM9do "石破下ろし加速！分裂深刻化！両院議員懇談会が5時間の長丁場で石破辞任要求！ジャーナリスト今井一さん・元博報堂作家本間龍さん")

C部長：これも、神のお導きです。このプログラムにご不満の方は、要件定義書を変えて、AIでコーディングすると良いと思います。”
