---
title: QEUR23_INDHS43 - 閑話休題～ヴェーダ数秘術をやってみる(併用法NO4-数秘術統合)   
date: 2025-08-19
tags: ["QEUシステム", "メトリックス", "Python言語", "Unsloth", "LLM", "データセット", "BONSAI", "LangGraph"]
excerpt: あたらしいLLMの学習体系を確立する
---

## QEUR23_INDHS43 - 閑話休題～ヴェーダ数秘術をやってみる(併用法NO4-数秘術統合)   

## ～  名前は意外と大切です ～

QEU:FOUNDER ： “今回のプロジェクトの占いの対象は、主に「この人（↓）」です。すなわち、**「21世紀の（現在までのところ、本当の意味で）世界を変えたイノベータ（革命者）」**を占いたいということです。”

![imageINDS2-43-1](/2025-08-19-QEUR23_INDHS43/imageINDS2-43-1.jpg) 

QEU:FOUNDER ： “ただし、今回はもう一人の**「超大物」**を招待しました。”

![imageINDS2-43-2](/2025-08-19-QEUR23_INDHS43/imageINDS2-43-2.jpg) 

D先生： “われらがアイドル！！今回は、ヴェーダ数秘術を使って運勢を解析したいということですね。ちなみに、本格的な運勢解析ツールである、インド占星術の「ナクシャトラ」では、以下のような運勢占いの結果でした（これは、前述のSJさんの場合です）。 “

![imageINDS2-43-3](/2025-08-19-QEUR23_INDHS43/imageINDS2-43-3.jpg) 

QEU:FOUNDER ： “確かに、あの頃のマッキントッシュはすごかった。さて、一方のヴェーダ数秘術でも運勢を読むことはできますが、とても簡便なものです。それでは、数秘術を統合した運勢グラフ生成プログラムを読んでみましょう。今回も、晒しは3分割しましょう。”

```python
# ---
# numerology_fortune_calculator.py
import json
import logging
import os
import re
from datetime import datetime
from typing import Dict, List, Tuple, Optional, TypedDict, Any
import matplotlib.pyplot as plt
import numpy as np
import pytz

try:
    from numerology_calculator import NumerologyCalculator, load_data as load_numerology_name_data
    NUMEROLOGY_CALCULATOR_AVAILABLE = True
    logging.info("numerology_calculator モジュールを正常にインポートしました。")
except ImportError as e:
    NUMEROLOGY_CALCULATOR_AVAILABLE = False
    logging.error(f"numerology_calculator モジュールのインポートに失敗しました: {e}")
    class NumerologyCalculator:
        def __init__(self, data=None):
            raise NotImplementedError("numerology_calculator モジュールが利用できません。")

try:
    from julian_birth_number_calculator import JulianBirthNumberCalculator, load_numerology_data as load_numerology_birth_data
    JULIAN_CALCULATOR_AVAILABLE = True
    logging.info("julian_birth_number_calculator モジュールを正常にインポートしました。")
except ImportError as e:
    JULIAN_CALCULATOR_AVAILABLE = False
    logging.error(f"julian_birth_number_calculator モジュールのインポートに失敗しました: {e}")
    class JulianBirthNumberCalculator:
        def __init__(self, data=None):
            raise NotImplementedError("julian_birth_number_calculator モジュールが利用できません。")

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

def load_locations_data() -> Dict[str, Any]:
    try:
        current_dir = os.path.dirname(os.path.abspath(__file__))
    except NameError:
        current_dir = os.path.abspath('.')
    locations_path = os.path.join(current_dir, 'locations.json')
    try:
        with open(locations_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        logger.error(f"locations.json ファイルが見つかりません: {locations_path}")
        return {}
    except json.JSONDecodeError as e:
        logger.error(f"locations.json の読み込みエラー: {e}")
        return {}

class SmallProgramState(TypedDict):
    full_name: str
    birth_datetime: datetime
    end_year: int
    llm_comment_year: int
    destiny_number: int
    soul_number: int
    personality_number: int
    birth_number: int
    personal_year_numbers: Dict[int, int]
    fortune_scores: Dict[int, Dict[str, float]]
    fortune_trend: Dict[str, List[Tuple[int, float]]]
    fortune_trend_advanced: Dict[str, List[Tuple[int, float]]]
    fortune_trend_graph: str
    fortune_trend_graph_advanced: str
    personal_year_graph: str
    errors: List[str]
    julian_date: Optional[float]
    report: str

```

D先生： “ここでは、すでに開発した2つのプログラムを「部品（クラス）」として読んで（import）います。あの2つをそのまま読み込めるんですか？”

QEU:FOUNDER： “残念ながら、そのままでは無理です。たぶんエラーが出てきます。各自がVibe Codingで調整してください。次は、ナクシャトラのプログラムと同様に、**運勢を読むためのパラメタ群**です。”

```python
class SmallProgramAnalyzer:
    def __init__(self):
        self.numerology_data = load_numerology_name_data() if NUMEROLO-GY_CALCULATOR_AVAILABLE else {}
        self.birth_data = load_numerology_birth_data() if JULIAN_CALCULATOR_AVAILABLE else {}
        self.locations_data = load_locations_data()

        # Adjusted fortune maps with higher values (3 to 7) for better score range
        self.destiny_fortune_map = {
            1: [5, 4, 5, 6, 6, 4, 5], 2: [4, 6, 6, 4, 4, 6, 3], 3: [5, 4, 6, 5, 6, 4, 4],
            4: [4, 5, 3, 6, 4, 5, 3], 5: [5, 4, 5, 4, 6, 4, 6], 6: [5, 6, 5, 4, 4, 6, 4],
            7: [4, 4, 4, 5, 5, 4, 4], 8: [6, 3, 4, 6, 5, 4, 6], 9: [5, 5, 5, 5, 6, 5, 5],
            11: [5, 3, 5, 5, 6, 4, 5], 22: [6, 4, 4, 6, 6, 5, 6], 33: [6, 5, 6, 5, 6, 6, 5]
        }
        self.soul_fortune_map = {
            1: [5, 4, 4, 6, 6, 4, 5], 2: [4, 6, 5, 4, 4, 6, 3], 3: [5, 4, 6, 5, 5, 4, 4],
            4: [4, 5, 3, 5, 4, 5, 3], 5: [5, 3, 5, 4, 6, 3, 6], 6: [4, 6, 5, 3, 4, 6, 3],
            7: [4, 3, 4, 5, 6, 4, 4], 8: [6, 3, 4, 6, 5, 4, 6], 9: [5, 5, 6, 5, 6, 6, 5],
            11: [5, 3, 5, 5, 6, 4, 5], 22: [6, 4, 4, 6, 6, 5, 6], 33: [6, 5, 6, 6, 6, 6, 6]
        }
        self.personality_fortune_map = {
            1: [5, 4, 4, 6, 5, 4, 5], 2: [4, 6, 6, 4, 4, 6, 3], 3: [5, 4, 6, 5, 5, 4, 4],
            4: [4, 5, 3, 6, 4, 5, 3], 5: [5, 3, 5, 4, 6, 3, 6], 6: [4, 6, 5, 4, 4, 6, 3],
            7: [4, 4, 3, 5, 5, 4, 4], 8: [6, 3, 4, 6, 5, 4, 6], 9: [5, 5, 5, 5, 6, 5, 5],
            11: [5, 3, 5, 5, 6, 4, 5], 22: [6, 4, 4, 6, 6, 5, 6], 33: [6, 5, 6, 5, 6, 6, 5]
        }
        self.py_fortune_matrix = {
            1: [5, 4, 4, 6, 6, 4, 5], 2: [4, 6, 5, 4, 4, 6, 3], 3: [5, 4, 6, 5, 6, 4, 4],
            4: [4, 5, 3, 6, 4, 5, 3], 5: [5, 4, 5, 4, 6, 4, 6], 6: [4, 6, 5, 4, 4, 6, 4],
            7: [4, 4, 3, 5, 6, 4, 4], 8: [6, 3, 4, 6, 5, 4, 6], 9: [5, 5, 6, 5, 6, 5, 5],
            11: [5, 3, 5, 6, 6, 4, 5], 22: [6, 4, 4, 6, 6, 5, 6], 33: [6, 5, 6, 6, 6, 6, 6]
        }

        # Compatibility table (unchanged)
        self.compatibility = {
            1: [1, 3, 5, 9], 2: [2, 4, 8], 3: [1, 3, 5, 9], 4: [2, 4, 8],
            5: [1, 3, 5, 9], 6: [6, 9], 7: [7], 8: [2, 4, 8], 9: [1, 3, 5, 6, 9],
            11: [11, 22, 33], 22: [11, 22, 33], 33: [11, 22, 33]
        }

        # Adjusted coefficients for stronger interaction terms
        self.coeff_d = 1.5
        self.coeff_s = 1.0
        self.coeff_p = 0.75

        # Adjusted score range for higher and more dynamic scores
        self.base_score_min = 0.0
        self.base_score_max = 15.0
        self.final_score_min = -5.0
        self.final_score_max = 10.0

```

D先生： “これらのパラメタは、どんなロジックをベースとしているんですか？”

QEU:FOUNDER ： “数秘術による運勢の基本は、**パーソナルイヤーナンバー**です。これは、他の数字（デスティニーナンバーetc）と同様に、[0～9,11,22,33]の間で動きます。逆に言うと、カバラ数秘術と同様に、9年周期で運勢が動くんです。ただし、今回は他の数字の交互作用(interaction)を加味しています。それでは、プログラムの最後のパートに行きましょう。”

```python
    def _reduce_to_single_digit(self, number: int) -> int:
        if number in [11, 22, 33]:
            return number
        while number > 9:
            number = sum(int(digit) for digit in str(number))
            if number in [11, 22, 33]:
                break
        return number

    def calculate_personal_year_number(self, birth_datetime: datetime, current_year: int) -> int:
        personal_year = (
            self._reduce_to_single_digit(birth_datetime.day) +
            self._reduce_to_single_digit(birth_datetime.month) +
            self._reduce_to_single_digit(current_year)
        )
        return self._reduce_to_single_digit(personal_year)

    def calculate_personal_year_numbers(self, birth_datetime: datetime, end_year: int) -> Dict[int, int]:
        personal_years = {}
        for year in range(birth_datetime.year, end_year + 1):
            personal_years[year] = self.calculate_personal_year_number(birth_datetime, year)
        return personal_years

    def _calculate_interaction_term(self, py_fortune: float, other_fortune: float, py_number: int, oth-er_number: int) -> float:
        if other_number in self.compatibility.get(py_number, []):
            return 1.5 if py_fortune > 4 else 0.0
        elif py_fortune < 4 and other_fortune < 4:
            return -1.0
        return 0.0

    def calculate_fortune_scores_advanced(self, personal_year: int, destiny_number: int, soul_number: int, personality_number: int) -> Dict[str, float]:
        categories = ["money", "health", "relation", "business", "growth", "family", "competition"]
        scores = {}
        py_fortunes = self.py_fortune_matrix.get(personal_year, [4]*7)
        d_fortunes = self.destiny_fortune_map.get(destiny_number, [4]*7)
        s_fortunes = self.soul_fortune_map.get(soul_number, [4]*7)
        p_fortunes = self.personality_fortune_map.get(personality_number, [4]*7)

        for i, category in enumerate(categories):
            py_f = py_fortunes[i]
            d_f = d_fortunes[i]
            s_f = s_fortunes[i]
            p_f = p_fortunes[i]

            interaction_d = self._calculate_interaction_term(py_f, d_f, personal_year, destiny_number)
            interaction_s = self._calculate_interaction_term(py_f, s_f, personal_year, soul_number)
            interaction_p = self._calculate_interaction_term(py_f, p_f, personal_year, personali-ty_number)

            base_score = py_f + self.coeff_d * interaction_d + self.coeff_s * interaction_s + self.coeff_p * interaction_p
            normalized_score = ((base_score - self.base_score_min) / (self.base_score_max - self.base_score_min)) * (self.final_score_max - self.final_score_min) + self.final_score_min
            final_score = max(self.final_score_min, min(self.final_score_max, normalized_score))
            scores[category] = round(final_score)  # Round to integer
        return scores

    def calculate_fortune_scores_simple(self, personal_year: int) -> Dict[str, float]:
        categories = ["money", "health", "relation", "business", "growth", "family", "competition"]
        scores = {}
        py_fortunes = self.py_fortune_matrix.get(personal_year, [4]*7)
        for i, category in enumerate(categories):
            py_f = py_fortunes[i]
            final_score = round((py_f - 3) * (10 / 4) - 5)  # Adjusted scaling for new range
            scores[category] = final_score
        return scores

    def calculate_fortune_trend(self, birth_datetime: datetime, end_year: int, destiny_number: int, soul_number: int, personality_number: int) -> Tuple[Dict[str, List[Tuple[int, float]]], Dict[str, List[Tuple[int, float]]]]:
        categories = ["money", "health", "relation", "business", "growth", "family", "competition"]
        fortune_trend_simple = {category: [] for category in categories}
        fortune_trend_advanced = {category: [] for category in categories}
        for year in range(birth_datetime.year, end_year + 1):
            personal_year = self.calculate_personal_year_number(birth_datetime, year)
            scores_simple = self.calculate_fortune_scores_simple(personal_year)
            scores_advanced = self.calculate_fortune_scores_advanced(personal_year, destiny_number, soul_number, personality_number)
            for category in categories:
                fortune_trend_simple[category].append((year, scores_simple[category]))
                fortune_trend_advanced[category].append((year, scores_advanced[category]))
        return fortune_trend_simple, fortune_trend_advanced

    def generate_fortune_trend_graph(self, fortune_trend: Dict[str, List[Tuple[int, float]]], filename: str, full_name: str, birth_year: int, end_year: int, title_suffix: str) -> str:
        plt.figure(figsize=(16, 8))
        try:
            from japanize_matplotlib import japanize
            japanize()
        except ImportError:
            logger.warning("japanize_matplotlib がインストールされていません。日本語ラベルが文字化けする可能性があります。")
        categories = ["money", "health", "relation", "business", "growth", "family", "competition"]
        japanese_names = {
            "money": "金銭", "health": "健康", "relation": "人間関係", "business": "事業",
            "growth": "成長", "family": "家族", "competition": "競争"
        }
        offsets = {"money": 0.1, "health": 0.1, "relation": -0.1, "business": -0.1, "growth": 0, "family": 0, "competition": 0}
        for category in categories:
            if category in fortune_trend and fortune_trend[category]:
                years = [point[0] for point in fortune_trend[category]]
                scores = [point[1] for point in fortune_trend[category]]
                # Apply 3-year moving average for smoothing
                window_size = 3
                weights = np.ones(window_size) / window_size
                smoothed_scores = np.convolve(scores, weights, mode='valid')
                # Adjust years for smoothed data (remove edges)
                smoothed_years = years[window_size//2:-(window_size//2)]
                # Plot original points
                plt.plot(years, [s + offsets[category] for s in scores], marker='o', linestyle='', la-bel=f"{japanese_names[category]} (点)")
                # Plot smoothed line
                plt.plot(smoothed_years, [s + offsets[category] for s in smoothed_scores], linestyle='-', la-bel=f"{japanese_names[category]} (平滑)")
        plt.title(f"{full_name} の運勢トレンド ({title_suffix})")
        plt.xlabel('年')
        plt.ylabel('運勢スコア')
        plt.ylim(-5.5, 6.5)  # Adjusted for new final_score_max
        plt.grid(True, linestyle='--', alpha=0.7)
        plt.legend(loc='upper right', fontsize='x-small')
        plt.xticks(range(birth_year, end_year + 1, max(1, (end_year - birth_year) // 10)))
        plt.tight_layout()
        plt.savefig(filename)
        plt.close()
        return filename

    def generate_personal_year_graph(self, personal_years: Dict[int, int], filename: str, full_name: str) -> str:
        plt.figure(figsize=(16, 8))
        try:
            from japanize_matplotlib import japanize
            japanize()
        except ImportError:
            logger.warning("japanize_matplotlib がインストールされていません。日本語ラベルが文字化けする可能性があります。")
        years = list(personal_years.keys())
        numbers = list(personal_years.values())
        # Apply 3-year moving average for smoothing
        window_size = 3
        weights = np.ones(window_size) / window_size
        smoothed_numbers = np.convolve(numbers, weights, mode='valid')
        smoothed_years = years[window_size//2:-(window_size//2)]
        # Plot original points
        plt.plot(years, numbers, marker='o', linestyle='', label='パーソナルイヤーナンバー (点)')
        # Plot smoothed line
        plt.plot(smoothed_years, smoothed_numbers, linestyle='-', label='パーソナルイヤーナンバー (平滑)')
        plt.yscale('log')  # 縦軸を対数軸に設定
        plt.xticks(years[::max(1, len(years)//10)])
        plt.yticks([1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33])
        for year, number in zip(years, numbers):
            plt.annotate(str(number), (year, number), textcoords="offset points", xytext=(0, 5), ha='center')
        plt.title(f"{full_name} のパーソナルイヤーナンバーの推移")
        plt.xlabel('年')
        plt.ylabel('パーソナルイヤーナンバー')
        plt.grid(axis='y', linestyle='--', alpha=0.7)
        plt.legend(loc='upper right', fontsize='x-small')
        plt.tight_layout()
        plt.savefig(filename)
        plt.close()
        return filename

    def generate_report(self, state: SmallProgramState) -> str:
        report = f"=== 小プログラムレポート ===\n"
        report += f"【基本情報】\n"
        report += f"- フルネーム: {state['full_name']}\n"
        report += f"- 生年月日: {state['birth_datetime'].strftime('%Y年%m月%d日')}\n"
        report += f"- 出生時刻: {state['birth_datetime'].strftime('%H:%M')}\n"
        julian_date_str = f"{state['julian_date']:.6f}" if state['julian_date'] is not None else "N/A"
        report += f"- ユリウス日: {julian_date_str}\n"
        report += f"【数秘術ナンバー】\n"
        report += f"- ディスティニーナンバー (भाग्यांक): {state['destiny_number']}\n"
        report += f"- ソウルナンバー (आत्मा इच्छा अंक): {state['soul_number']}\n"
        report += f"- パーソナリティナンバー (व्यक्तित्व अंक): {state['personality_number']}\n"
        report += f"- ライフパスナンバー (जीवन पथ संख्या): {state['birth_number']}\n"
        report += f"【運勢スコア（{state['llm_comment_year']}年）】\n"
        if state['fortune_scores'].get(state['llm_comment_year']):
            for category, score in state['fortune_scores'][state['llm_comment_year']].items():
                japanese_name = {
                    "money": "金銭", "health": "健康", "relation": "人間関係", "business": "事業",
                    "growth": "成長", "family": "家族", "competition": "競争"
                }.get(category, category)
                report += f"- {japanese_name}: {score:.0f}\n"
        return report

def extract_english_name(full_name: str) -> str:
    """フルネームから英語名のみを抽出する"""
    english_part = re.sub(r'[^a-zA-Z\s_]', '', full_name).strip()
    english_part = re.sub(r'\s+', '_', english_part)
    return english_part

def calculate_and_generate_results(full_name: str, birth_datetime: datetime, end_year: int, llm_comment_year: int, birth_location: str) -> Dict[str, Any]:
    logger.info("小プログラム処理を開始します。")
    state: SmallProgramState = {
        "full_name": full_name,
        "birth_datetime": birth_datetime,
        "end_year": end_year,
        "llm_comment_year": llm_comment_year,
        "destiny_number": 0,
        "soul_number": 0,
        "personality_number": 0,
        "birth_number": 0,
        "personal_year_numbers": {},
        "fortune_scores": {},
        "fortune_trend": {},
        "fortune_trend_advanced": {},
        "fortune_trend_graph": "",
        "fortune_trend_graph_advanced": "",
        "personal_year_graph": "",
        "errors": [],
        "julian_date": None,
        "report": ""
    }

    analyzer = SmallProgramAnalyzer()
    locations_data = analyzer.locations_data
    if birth_location not in locations_data:
        error_msg = f"出生地 '{birth_location}' が locations.json に見つかりません。"
        state["errors"].append(error_msg)
        logger.error(error_msg)
        localized_birth_datetime = birth_datetime.replace(tzinfo=pytz.utc)
    else:
        tz_name = locations_data[birth_location].get("timezone")
        if not tz_name:
            error_msg = f"出生地 '{birth_location}' のタイムゾーン情報が不完全です。"
            state["errors"].append(error_msg)
            logger.error(error_msg)
            localized_birth_datetime = birth_datetime.replace(tzinfo=pytz.utc)
        else:
            try:
                tz = pytz.timezone(tz_name)
                localized_birth_datetime = tz.localize(birth_datetime)
                logger.info(f"タイムゾーン '{tz_name}' を '{birth_location}' に適用しました。")
            except Exception as e:
                error_msg = f"タイムゾーン '{tz_name}' の設定に失敗しました: {e}"
                state["errors"].append(error_msg)
                logger.error(error_msg)
                localized_birth_datetime = birth_datetime.replace(tzinfo=pytz.utc)
    
    state["birth_datetime"] = localized_birth_datetime

    if NUMEROLOGY_CALCULATOR_AVAILABLE:
        try:
            num_calc = NumerologyCalculator()
            state["destiny_number"], _, _ = num_calc.calculate_destiny_number(full_name)
            state["soul_number"], _, _ = num_calc.calculate_soul_number(full_name)
            state["personality_number"], _, _ = num_calc.calculate_personality_number(full_name)
        except Exception as e:
            error_msg = f"数秘術計算エラー (Aプログラム): {str(e)}"
            state["errors"].append(error_msg)
            logger.error(error_msg)
            state.update({"destiny_number": 0, "soul_number": 0, "personality_number": 0})

    if JULIAN_CALCULATOR_AVAILABLE:
        try:
            julian_calc = JulianBirthNumberCalculator()
            julian_result = julian_calc.calculate(localized_birth_datetime, end_year)
            state["birth_number"] = julian_result["birth_number"]
            state["julian_date"] = julian_result["julian_date"]
        except Exception as e:
            error_msg = f"ライフパスナンバー計算エラー (Bプログラム): {str(e)}"
            state["errors"].append(error_msg)
            logger.error(error_msg)
            state["birth_number"] = 0

    state["personal_year_numbers"] = analyz-er.calculate_personal_year_numbers(localized_birth_datetime, end_year)
    state["fortune_scores"][llm_comment_year] = analyzer.calculate_fortune_scores_advanced(
        state["personal_year_numbers"].get(llm_comment_year, 1),
        state["destiny_number"], state["soul_number"], state["personality_number"]
    )
    state["fortune_trend"], state["fortune_trend_advanced"] = analyzer.calculate_fortune_trend(
        localized_birth_datetime, end_year, state["destiny_number"], state["soul_number"], state["personality_number"]
    )

    english_name = extract_english_name(full_name)
    fortune_trend_graph_simple = f"{english_name}_fortune_trend_simple.png"
    fortune_trend_graph_advanced = f"{english_name}_fortune_trend_advanced.png"
    personal_year_graph = f"{english_name}_personal_year.png"

    state["fortune_trend_graph"] = analyzer.generate_fortune_trend_graph(
        state["fortune_trend"], fortune_trend_graph_simple, full_name, localized_birth_datetime.year, end_year, "パーソナルイヤーのみ"
    )
    state["fortune_trend_graph_advanced"] = analyzer.generate_fortune_trend_graph(
        state["fortune_trend_advanced"], fortune_trend_graph_advanced, full_name, local-ized_birth_datetime.year, end_year, "高精度 (PY+D+S+P)"
    )
    state["personal_year_graph"] = analyzer.generate_personal_year_graph(
        state["personal_year_numbers"], personal_year_graph, full_name
    )

    try:
        num_calc_report = ""
        julian_calc_report = ""
        if NUMEROLOGY_CALCULATOR_AVAILABLE:
            try:
                num_calc_instance = NumerologyCalculator()
                num_calc_report = num_calc_instance.generate_report(full_name)
            except Exception as e:
                error_msg = f"Aプログラムレポート生成エラー: {str(e)}"
                state["errors"].append(error_msg)
                logger.error(error_msg)
                num_calc_report = "Aプログラムレポート生成失敗"
        if JULIAN_CALCULATOR_AVAILABLE:
            try:
                julian_calc_instance = JulianBirthNumberCalculator()
                b_results = julian_calc_instance.calculate(localized_birth_datetime, end_year)
                if 'error' not in b_results:
                    julian_calc_report = f"\n--- {localized_birth_datetime} のユリウス日・運命数計算 ---\n"
                    julian_calc_report += f"ユリウス日 (JD): {b_results['julian_date']}\n"
                    julian_ymd = b_results['julian_ymd']
                    julian_calc_report += f"ユリウス暦: {julian_ymd[0]}年{julian_ymd[1]:02d}月{julian_ymd[2]:02d}日\n"
                    julian_calc_report += f"運命数 (ライフパスナンバー) (जीवन पथ संख्या): {b_results['birth_number']}\n"
                    julian_calc_report += "計算式:\n"
                    julian_calc_report += b_results['calculation_formula'] + "\n"
                    julian_calc_report += "\n--- 運命数詳細 ---\n"
                    julian_calc_report += f"  惑星 (ग्रह): {b_results['details'].get('planet', 'N/A')}\n"
                    julian_calc_report += f"  強み (शक्तियां): {', '.join(b_results['details'].get('strengths', ['N/A']))}\n"
                    julian_calc_report += f"  弱み (कमजोरियाँ): {', '.join(b_results['details'].get('weaknesses', ['N/A']))}\n"
                    julian_calc_report += f"  人生のテーマ (जीवन के विषय): {b_results['details'].get('life_themes', 'N/A')}\n"
                    julian_calc_report += f"  健康上のリスク (स्वास्थ्य जोखिम): {', '.join(b_results['details'].get('health_risks', ['N/A']))}\n"
                    julian_calc_report += f"  健康アドバイス (स्वास्थ्य सलाह): {', '.join(b_results['details'].get('health_advice', ['N/A']))}\n"
                else:
                    julian_calc_report = f"\nBプログラムエラー: {b_results['error']}\n"
            except Exception as e:
                error_msg = f"Bプログラムレポート生成エラー: {str(e)}"
                state["errors"].append(error_msg)
                logger.error(error_msg)
                julian_calc_report = "Bプログラムレポート生成失敗"
    except Exception as e:
        error_msg = f"レポート生成エラー: {str(e)}"
        state["errors"].append(error_msg)
        logger.error(error_msg)
        num_calc_report = "Aプログラムレポート生成失敗"
        julian_calc_report = "Bプログラムレポート生成失敗"

    state["report"] = num_calc_report + julian_calc_report + "\n" + analyzer.generate_report(state)
    logger.info("小プログラム処理が完了しました。")
    return state

if __name__ == "__main__":
    full_name = "Steve Jobs"
    birth_date = datetime(1955, 2, 24, 19, 0)
    birth_location = "ロサンゼルス"
    end_year = 2012
    llm_comment_year = 2010

    print(f"--- 処理開始: {full_name} ---")
    result = calculate_and_generate_results(full_name, birth_date, end_year, llm_comment_year, birth_location)
    print(result["report"])
    print(f"\n運勢トレンドグラフ (単純): {result['fortune_trend_graph']}")
    print(f"運勢トレンドグラフ (高精度): {result['fortune_trend_graph_advanced']}")
    print(f"パーソナルイヤーグラフ: {result['personal_year_graph']}")
    if result["errors"]:
        print("\n=== エラー ===")
        for error in result["errors"]:
            print(f"- {error}")
    print("\n--- 処理完了 ---\n")

    full_name2 = "安倍晋三(Abe Shinzo)"
    birth_date2 = datetime(1954, 9, 21, 9, 0)
    birth_location2 = "東京"
    end_year2 = 2022
    llm_comment_year2 = 2021

    print(f"--- 処理開始: {full_name2} ---")
    result2 = calculate_and_generate_results(full_name2, birth_date2, end_year2, llm_comment_year2, birth_location2)
    print(result2["report"])
    print(f"\n運勢トレンドグラフ (単純): {result2['fortune_trend_graph']}")
    print(f"運勢トレンドグラフ (高精度): {result2['fortune_trend_graph_advanced']}")
    print(f"パーソナルイヤーグラフ: {result2['personal_year_graph']}")
    if result2["errors"]:
        print("\n=== エラー ===")
        for error in result2["errors"]:
            print(f"- {error}")
    print("\n--- 処理完了 ---")

```

QEU:FOUNDER ： “このプログラムを実行すると、最初は、以前作成したA,Bプログラムの出力情報がバラバラとでてきます。”

![imageINDS2-43-4](/2025-08-19-QEUR23_INDHS43/imageINDS2-43-4.jpg) 

QEU:FOUNDER ： “肝心の運勢の作成は、これからです。まずは、パーソナルイヤーナンバーの変動のグラフが出てきます。”

![imageINDS2-43-5](/2025-08-19-QEUR23_INDHS43/imageINDS2-43-5.jpg) 

D先生：“このグラフでは、Y軸の数字が大きければ、運勢がいいんですか”

QEU:FOUNDER ： “これらは、単に**「運勢のフェーズ」を示している数字**にすぎません。具体的な運勢の良し悪しを知りたいのであれば、先ほどのパラメタを使うしかないです。そうすると、以下のようなグラフが出てきます。”

![imageINDS2-43-6](/2025-08-19-QEUR23_INDHS43/imageINDS2-43-6.jpg) 

D先生：“パーソナルイヤーナンバーだけでやった見たのが、この下のグラフですね。そして、他の数字との交互作用を加味したのが上のグラフです。それにしても、単に9年の周期曲線を見せられてもねえ・・・。”

QEU:FOUNDER ： “簡便な数秘術なんですから、運勢のアップダウンのスコア変動については、まあ「こんなもの」かもしれません。次は、D先生の大好物の人物の占いをやります。”

D先生：“おお・・・。あの人ですか。”

QEU:FOUNDER ： “いきなり運勢変動グラフを見てみます。”

![imageINDS2-43-7](/2025-08-19-QEUR23_INDHS43/imageINDS2-43-7.jpg) 

D先生：“**しょぼい**なぁ・・・。”

QEU:FOUNDER ： “それをいったらダメだ！！”

D先生： “すいません・・・。ちょっと面白い実験をやってみたいです。さっきのSJ氏（21世紀最強の革命者）の生年月日に、J国頑固老人のアイドルの名前を組み合わせると、運勢はどうなるのでしょうか？果たして、両者が合体して「21世紀最強のアイドル」が生まれるのでしょうか？”

QEU:FOUNDER ： “つまり、生年月日と名前の交互作用がどうなるのかを知りたいのですね？それでは、テストをやってみましょう。”

![imageINDS2-43-8](/2025-08-19-QEUR23_INDHS43/imageINDS2-43-8.jpg) 

D先生： “S氏は、強力なライフパスナンバー（マスターナンバー：11）を持っているのですが、その彼をもってしても運勢がショボくなるんですね。さすが、A氏、恐るべし・・・。”

QEU:FOUNDER ： “結局、名前と生年月日には相性があるんですねぇ・・・。そう考えれば、おもしろいソフトウェアを提案することができます。”

![imageINDS2-43-9](/2025-08-19-QEUR23_INDHS43/imageINDS2-43-9.jpg) 

D先生： “子供やペットのために、生年月日を元にして、ベストの名前を選ぶプログラムをつくることができます！男女それぞれ100通りの名前を登録して、最適化計算をすると、なかなかよさげなサービスができるでしょう。”

QEU:FOUNDER ： “それには、**パラメータの最適化が課題**ですね。”

D先生：“今回も、前回と同様に、AIを使ってチューニングをやってみたんですか？”

QEU:FOUNDER ： “今回は、A氏とS氏の名前をプロンプトに入れてみたら、うまく答えが出てきました。ちなみに、それはGROKを使ってみたんですが・・・。それでも、一定レベルのパラメータの信頼性を得るには、最低200人ぐらいの人物を使って、最適化、妥当性検証をしなければいけませんね。”

D先生：“めんどくさ・・・。きっと誰かが作ってくれるでしょう。”


## ～ まとめ ～

QEU:FOUNDER ： “これは、ちょっと驚きました。”

[![MOVIE1](http://img.youtube.com/vi/kKtK9aVKM7A/0.jpg)](http://www.youtube.com/watch?v=kKtK9aVKM7A "亲历硅谷科技公司大裁员 5年巨变-从疯狂抢人到裁员潮 ｜ AI时代生存法则")

C部長：“別におどろくこともないでしょう？”

![imageINDS2-43-10](/2025-08-19-QEUR23_INDHS43/imageINDS2-43-10.jpg) 

C部長：“最近、この手のニュースが、頻繁に流れてきています。”

QEU:FOUNDER ： “動画で驚いたのは、いわゆるIT（GAFAMなど）業界では、**病気の蔓延が終わった2022年から雇用の縮小が始まっていた**んです。さすがに、Ａ国くらいは、ずっと景気がいいとばかり思っていました。”

![imageINDS2-43-11](/2025-08-19-QEUR23_INDHS43/imageINDS2-43-11.jpg) 

D先生：“それにしても、このような先進的な社会で働いている人たちにとっては、もう、たまったものではないですね。”

![imageINDS2-43-12](/2025-08-19-QEUR23_INDHS43/imageINDS2-43-12.jpg) 

D先生：“十年前で、TWであったよね。似たような現象が・・・。”

C部長：“D先生とFOUNDERが悪いんですよ。Vibe Codingなんぞをやるから・・・。**Computer Scienceの魅力が地に落ちた**じゃないですか…。”

![imageINDS2-43-13](/2025-08-19-QEUR23_INDHS43/imageINDS2-43-13.jpg) 

D先生：“すいません・・・。私がF級戦犯です。”

