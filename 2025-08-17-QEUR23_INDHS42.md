---
title: QEUR23_INDHS42 - 閑話休題～ヴェーダ数秘術をやってみる(併用法NO3-パラメタ最適化)   
date: 2025-08-17
tags: ["QEUシステム", "メトリックス", "Python言語", "Unsloth", "LLM", "データセット", "BONSAI", "LangGraph"]
excerpt: あたらしいLLMの学習体系を確立する
---

## QEUR23_INDHS42 - 閑話休題～ヴェーダ数秘術をやってみる(併用法NO3-パラメタ最適化)   

## ～  パラメタ最適化の未来が見えて来た ～

QEU:FOUNDER ： “今回のプロジェクトの占いの対象は、この人（↓）です。すなわち、21世紀の現在までのところ、本当の意味で、世界を変えた最大ののイノベータ（革命者）を占いたいということです。”

![imageINDS2-42-1](/2025-08-17-QEUR23_INDHS42/imageINDS2-42-1.jpg) 

D先生： “今回の改善したいプログラムは、・・・。**「nakshatra_fortune_calculator.py」**ですかね・・・。 “

**(ファイル構成)**

```python

project_directory/
├── main_program.py
├── nakshatra_fortune_calculator.py
├── numerology_calculator.py 
├── julian_birth_number_calculator.py 
├── locations.json
├── nakshatra_data.json
├── career_data.json
└── skyfield_data/ (Skyfieldが自動生成)
    └── de440s.bsp (または de421.bsp)
	
```

QEU:FOUNDER ： “インド占星術における、ナクシャトラというのは、さすがに知らない人が多いかもしれません。”

![imageINDS2-42-2](/2025-08-17-QEUR23_INDHS42/imageINDS2-42-2.jpg) 

D先生： “西洋占星術の運勢は、惑星の位置関係から評価されるんですが、インド占星術では月の動きが中心になります。月の状態は27または28分割されています。西洋占星術とインド占星術の共通したところは、出生時間が必要です。アセンダント（生まれたときに上ってくる星座）がわからないと、十二宮（ハウス）が書けないです。先ほどのイノベータは、生まれた時間が明確になっています。生誕時間は、19時ごろでしたよね。”

QEU:FOUNDER： “今回は、ちょっと面白い展開になるんだよ。長いプログラムになるのだが、三分割されます。”

```python
# ---
# nakshatra_fortune_calculator.py
import json
import logging
import os
import re
from datetime import datetime, timedelta
import pytz
from skyfield.api import load, utc
from skyfield import almanac
import matplotlib.pyplot as plt
import matplotlib as mpl
import numpy as np
from typing import Dict, List, Tuple, Any

# ロギング設定
logging.basicConfig(level=logging.INFO, 
                    format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# matplotlibのフォント設定を事前に設定（日本語対応）
def setup_matplotlib():
    """matplotlibの日本語フォント設定を強化"""
    try:
        # 日本語フォントの優先順位リスト
        japanese_fonts = [
            'Hiragino Maru Gothic Pro',
            'Hiragino Mincho Pro',
            'Osaka',
            'Meiryo',
            'IPAGothic',
            'TakaoPGothic',
            'Noto Sans CJK JP',
            'SimHei',
            'DejaVu Sans'
        ]
        
        # matplotlibのデフォルトフォント設定
        mpl.rcParams['font.family'] = 'sans-serif'
        mpl.rcParams['font.sans-serif'] = japanese_fonts
        mpl.rcParams['axes.unicode_minus'] = False  # マイナス記号の表示設定
        
        # 不要なmatplotlibロガーのレベルを上げる
        logging.getLogger('matplotlib.font_manager').setLevel(logging.ERROR)
        logging.getLogger('matplotlib.pyplot').setLevel(logging.ERROR)
        
        logger.info("matplotlibの日本語フォント設定が完了しました")
    except Exception as e:
        logger.warning(f"matplotlibのフォント設定で問題が発生: {str(e)}")
        # 代替フォント設定
        mpl.rcParams['font.family'] = 'DejaVu Sans'
        mpl.rcParams['axes.unicode_minus'] = False

# matplotlibの設定を最初に実行
setup_matplotlib()

# メインデータのロード
def load_main_data() -> Dict[str, Any]:
    """JSONデータをロード"""
    try:
        # __file__が使えない環境でも動作するように修正
        try:
            # 通常のPythonスクリプト実行時
            current_dir = os.path.dirname(os.path.abspath(__file__))
        except NameError:
            # Jupyter Notebookなど__file__が使えない環境
            current_dir = os.getcwd()
        
        locations_path = os.path.join(current_dir, 'locations.json')
        nakshatra_path = os.path.join(current_dir, 'nakshatra_data.json')
        
        if not os.path.exists(locations_path):
            logger.error(f"locations.jsonが見つかりません: {locations_path}")
            raise FileNotFoundError(f"locations.jsonが見つかりません")
        if not os.path.exists(nakshatra_path):
            logger.error(f"nakshatra_data.jsonが見つかりません: {nakshatra_path}")
            raise FileNotFoundError(f"nakshatra_data.jsonが見つかりません")
        
        with open(locations_path, 'r', encoding='utf-8') as f:
            locations_data = json.load(f)
        with open(nakshatra_path, 'r', encoding='utf-8') as f:
            nakshatra_data = json.load(f)
        
        logger.info("JSONデータのロードが成功しました")
        return {
            'locations': locations_data,
            'nakshatra_data': nakshatra_data,
        }
    except Exception as e:
        logger.error(f"メインデータのロード中にエラー: {str(e)}")
        return {
            'locations': {},
            'nakshatra_data': [],
        }

MAIN_DATA = load_main_data()

def convert_to_11point_scale(score: float, category: str) -> int:
    """0.5-5.5のスコアを-5から+5の11ポイントスケールに変換
    
    Args:
        score: 0.5-5.5の範囲のスコア
        category: カテゴリ名
    
    Returns:
        -5から+5の整数値
    """
    # 0.5-5.5を-5.0から+5.0にスケーリング（3.0が0に相当）
    scaled = (score - 3.0) * 5.0 / 2.0
    # 整数に丸め（四捨五入）
    return max(-5, min(5, int(round(scaled))))

def get_score_label(score: int) -> str:
    """スコア値からラベルを取得"""
    if score == 5:
        return "大吉 (+5)"
    elif score == 4:
        return "中吉 (+4)"
    elif score == 3:
        return "小吉 (+3)"
    elif score == 2:
        return "末吉 (+2)"
    elif score == 1:
        return "半吉 (+1)"
    elif score == 0:
        return "普通 (0)"
    elif score == -1:
        return "小凶 (-1)"
    elif score == -2:
        return "小凶 (-2)"
    elif score == -3:
        return "小凶 (-3)"
    elif score == -4:
        return "中凶 (-4)"
    else:  # score == -5
        return "大凶 (-5)"

class VedicAstrologyAnalyzer:
    def __init__(self):
        if not MAIN_DATA['locations'] or not MAIN_DATA['nakshatra_data']:
            logger.error("必要なJSONデータがロードできていません。プログラムを終了します。")
            raise RuntimeError("必要なJSONデータがロードできていません")
        
        self.locations = MAIN_DATA['locations']
        self.nakshatra_data = MAIN_DATA['nakshatra_data']
        self._init_skyfield()
    
    def _init_skyfield(self):
        """Skyfieldの初期化とAyanamsa計算の準備"""
        try:
            temp_dir = os.path.join(os.getcwd(), 'skyfield_data')
            os.makedirs(temp_dir, exist_ok=True)
            load.directory = temp_dir
            
            logger.info("Ephemeris (de440s.bsp)をロード中...")
            try:
                self.ephemeris = load('de440s.bsp')
                logger.info("Ephemeris de440s.bspのロードが完了しました")
            except Exception as e:
                logger.warning(f"de440s.bspのロードに失敗: {str(e)}")
                logger.info("代替としてde421.bspを使用します")
                self.ephemeris = load('de421.bsp')
            
            self.ts = load.timescale(builtin=True)
        except Exception as e:
            logger.error(f"Ephemerisのロードに失敗: {str(e)}")
            raise
    
    def _calculate_lahiri_ayanamsa(self, birth_datetime: datetime) -> float:
        """Lahiri方式による正確なAyanamsa値を計算"""
        try:
            year = birth_datetime.year
            month = birth_datetime.month
            base_year = 2000
            base_ayanamsa = 23.853333  # 23°51'12"
            annual_precession = 50.29 / 3600  # 度単位
            month_adjustment = (month - 1) * (50.29 / 12 / 3600)
            
            years_diff = year - base_year
            ayanamsa = base_ayanamsa + (years_diff * annual_precession) + month_adjustment
            
            logger.info(f"Lahiri Ayanamsa計算: {ayanamsa:.4f}度 (基準: {base_year}年)")
            return ayanamsa
        except Exception as e:
            logger.error(f"Ayanamsa計算エラー: {str(e)}")
            return 23.85  # 2000年基準の標準値
    
    def _find_nakshatra(self, moon_longitude: float, ayanamsa_value: float) -> Dict[str, Any]:
        """月の黄経からナクシャトラを特定"""
        corrected_longitude = moon_longitude - ayanamsa_value
        corrected_longitude = corrected_longitude % 360
        if corrected_longitude < 0:
            corrected_longitude += 360
        
        logger.debug(f"補正後月黄経: {corrected_longitude:.4f}度 (元: {moon_longitude:.4f}度, Aya-namsa: {ayanamsa_value:.4f}度)")
        
        for nakshatra in self.nakshatra_data:
            if nakshatra["start_deg"] <= corrected_longitude < nakshatra["end_deg"]:
                pada_size = 13.3333 / 4
                relative_pos = corrected_longitude - nakshatra["start_deg"]
                pada_index = int(relative_pos / pada_size)
                if pada_index > 3:
                    pada_index = 3
                pada = nakshatra["padas"][pada_index]
                pada_position = (relative_pos % pada_size) / pada_size
                
                return {
                    "nakshatra": nakshatra["name"],
                    "ruler": nakshatra["ruler"],
                    "deity": nakshatra["deity"],
                    "pada": pada["name"],
                    "pada_characteristics": pada["characteristics"],
                    "pada_index": pada_index,
                    "pada_position": pada_position,
                    "moon_longitude": moon_longitude,
                    "corrected_longitude": corrected_longitude,
                    "nakshatra_index": self.nakshatra_data.index(nakshatra)
                }
        
        logger.warning(f"ナクシャトラが特定できませんでした (黄経: {moon_longitude:.4f}°, 補正後: {corrected_longitude:.4f}°)")
        
        # 最も近いナクシャトラを探す
        min_diff = float('inf')
        closest_nakshatra = None
        for nakshatra in self.nakshatra_data:
            mid_point = (nakshatra["start_deg"] + nakshatra["end_deg"]) / 2
            diff = min(
                abs(corrected_longitude - mid_point),
                abs(corrected_longitude - mid_point + 360),
                abs(corrected_longitude - mid_point - 360)
            )
            if diff < min_diff:
                min_diff = diff
                closest_nakshatra = nakshatra
        
        if closest_nakshatra:
            pada_size = 13.3333 / 4
            relative_pos = corrected_longitude - closest_nakshatra["start_deg"]
            pada_index = int(relative_pos / pada_size)
            if pada_index > 3:
                pada_index = 3
            pada = closest_nakshatra["padas"][pada_index]
            pada_position = (relative_pos % pada_size) / pada_size
            
            return {
                "nakshatra": closest_nakshatra["name"],
                "ruler": closest_nakshatra["ruler"],
                "deity": closest_nakshatra["deity"],
                "pada": pada["name"],
                "pada_characteristics": pada["characteristics"],
                "pada_index": pada_index,
                "pada_position": pada_position,
                "moon_longitude": moon_longitude,
                "corrected_longitude": corrected_longitude,
                "nakshatra_index": self.nakshatra_data.index(closest_nakshatra)
            }
        
        # 最終的なフォールバック
        last_nakshatra = self.nakshatra_data[-1]
        pada = last_nakshatra["padas"][-1]
        return {
            "nakshatra": last_nakshatra["name"],
            "ruler": last_nakshatra["ruler"],
            "deity": last_nakshatra["deity"],
            "pada": pada["name"],
            "pada_characteristics": pada["characteristics"],
            "pada_index": 3,
            "pada_position": 1.0,
            "moon_longitude": moon_longitude,
            "corrected_longitude": corrected_longitude,
            "nakshatra_index": len(self.nakshatra_data) - 1
        }
    
    def _get_vimshottari_dasha_periods(self) -> Dict[str, float]:
        """Vimshottari Dashaシステムの周期を取得"""
        return {
            "केतु (Ketu: ケートゥ)": 7.0,
            "शुक्र (Shukra: 金星)": 20.0,
            "सूर्य (Surya: 太陽)": 6.0,
            "चन्द्र (Chandra: 月)": 10.0,
            "मंगल (Mangal: 火星)": 7.0,
            "राहु (Rahu: ラーフ)": 18.0,
            "बृहस्पति (Brihaspati: 木星)": 16.0,
            "शनि (Shani: 土星)": 19.0,
            "बुध (Budh: 水星)": 17.0
        }

```

D先生： “ここまでで、「おもしろいこと」ってあるんですか？”

QEU:FOUNDER ： “ここまでは、特にないですよ。まあ、ちょっと待ってください。次ですかね、おもしろいのは・・・。”

```python

    # ダシャスコア取得（最適化）
    def _get_dasha_scores(self, dasha_name: str) -> Dict[str, float]:
        """ダシャ名から運勢スコアを取得（0.0-6.0の範囲に拡張）"""
        dasha_scores = {
            "केतु (Ketu: ケートゥ)": {
                "relation": 1.0, "health": 1.5, "business": 1.8, "growth": 1.5,
                "family": 1.2, "competition": 1.0, "money": 1.8
            },
            "शुक्र (Shukra: 金星)": {
                "relation": 5.5, "health": 4.5, "business": 4.5, "growth": 4.0,
                "family": 4.5, "competition": 5.0, "money": 5.5
            },
            "सूर्य (Surya: 太陽)": {
                "relation": 3.5, "health": 4.5, "business": 6.0, "growth": 5.0,
                "family": 3.5, "competition": 6.0, "money": 5.0
            },
            "चन्द्र (Chandra: 月)": {
                "relation": 4.0, "health": 3.0, "business": 2.5, "growth": 2.5,
                "family": 4.0, "competition": 2.0, "money": 3.0
            },
            "मंगल (Mangal: 火星)": {
                "relation": 1.5, "health": 2.0, "business": 5.0, "growth": 3.5,
                "family": 2.0, "competition": 5.5, "money": 3.0
            },
            "राहु (Rahu: ラーフ)": {
                "relation": 2.0, "health": 2.5, "business": 6.0, "growth": 4.0,
                "family": 2.5, "competition": 6.0, "money": 5.0
            },
            "बृहस्पति (Brihaspati: 木星)": {
                "relation": 4.5, "health": 5.5, "business": 4.5, "growth": 5.5,
                "family": 4.5, "competition": 3.5, "money": 4.5
            },
            "शनि (Shani: 土星)": {
                "relation": 1.5, "health": 2.8, "business": 2.5, "growth": 2.0,
                "family": 3.0, "competition": 1.5, "money": 2.5
            },
            "बुध (Budh: 水星)": {
                "relation": 4.5, "health": 4.5, "business": 5.5, "growth": 6.0,
                "family": 4.5, "competition": 4.5, "money": 5.0
            }
        }

        base_dasha_name = dasha_name.split('(')[0].strip()
        for key in dasha_scores.keys():
            if base_dasha_name in key:
                return dasha_scores[key]

        logger.warning(f"ダシャ '{dasha_name}' に対応するスコアが見つかりません。デフォルト値を使用します")
        return {
            "relation": 3.0, "health": 3.0, "business": 3.0, "growth": 3.0,
            "family": 3.0, "competition": 3.0, "money": 3.0
        }

    # ナクシャトラスコア取得（最適化）
    def _get_nakshatra_scores(self, nakshatra_name: str, pada: int) -> Dict[str, float]:
        """ナクシャトラ名とパダから運勢スコアを取得（0.0-6.0の範囲に拡張）"""
        # 基本スコアの取得
        base_scores = {
            "अश्विनी (Ashvini: アスヴィニ)": {
                "relation": 2.0, "health": 2.5, "business": 2.5, "growth": 2.0,
                "family": 2.0, "competition": 3.0, "money": 2.5
            },
            "भरणी (Bharani: バラニ)": {
                "relation": 1.5, "health": 2.0, "business": 3.0, "growth": 2.0,
                "family": 1.5, "competition": 3.5, "money": 2.0
            },
            "कृत्तिका (Krittika: クリッティカー)": {
                "relation": 2.5, "health": 3.0, "business": 6.0, "growth": 4.0,
                "family": 2.5, "competition": 6.0, "money": 4.0
            },
            "रोहिणी (Rohini: ロヒニー)": {
                "relation": 4.5, "health": 3.5, "business": 3.5, "growth": 3.5,
                "family": 4.5, "competition": 3.0, "money": 4.0
            },
            "मृगशीर्ष (Mrigashira: ミガシーラ)": {
                "relation": 3.0, "health": 3.0, "business": 3.5, "growth": 3.5,
                "family": 3.0, "competition": 3.0, "money": 3.0
            },
            "आर्द्रा (Ardra: アルドラー)": {
                "relation": 2.0, "health": 2.5, "business": 4.5, "growth": 3.0,
                "family": 2.0, "competition": 4.5, "money": 3.5
            },
            "पुनर्वसु (Punarvasu: プナルヴァス)": {
                "relation": 4.0, "health": 4.0, "business": 3.5, "growth": 4.5,
                "family": 4.0, "competition": 3.0, "money": 4.0
            },
            "पुष्य (Pushya: プシュヤ)": {
                "relation": 3.5, "health": 4.5, "business": 3.5, "growth": 4.5,
                "family": 3.5, "competition": 2.5, "money": 3.5
            },
            "आश्लेषा (Ashlesha: アシュレーシャ)": {
                "relation": 2.0, "health": 3.0, "business": 4.0, "growth": 3.0,
                "family": 2.5, "competition": 4.0, "money": 3.5
            },
            "मघा (Magha: マガ)": {
                "relation": 1.5, "health": 2.0, "business": 3.5, "growth": 2.5,
                "family": 2.0, "competition": 4.0, "money": 3.0
            },
            "पूर्वफाल्गुनी (Purva Phalguni: プルヴァ・ファルグニ)": {
                "relation": 4.5, "health": 4.0, "business": 4.5, "growth": 4.0,
                "family": 4.0, "competition": 4.5, "money": 5.0
            },
            "उत्तरफाल्गुनी (Uttara Phalguni: ウッタラ・ファルグニ)": {
                "relation": 4.0, "health": 4.0, "business": 4.0, "growth": 4.5,
                "family": 4.5, "competition": 3.5, "money": 4.5
            },
            "हस्त (Hasta: ハスタ)": {
                "relation": 3.5, "health": 3.5, "business": 4.5, "growth": 4.0,
                "family": 3.5, "competition": 4.0, "money": 5.0
            },
            "चित्रा (Chitra: チトラ)": {
                "relation": 3.0, "health": 3.0, "business": 5.0, "growth": 4.0,
                "family": 3.0, "competition": 5.0, "money": 4.5
            },
            "स्वाति (Swati: スワーティ)": {
                "relation": 2.5, "health": 3.0, "business": 4.5, "growth": 4.0,
                "family": 2.5, "competition": 4.5, "money": 4.0
            },
            "विशाखा (Vishakha: ヴィシャーカ)": {
                "relation": 3.0, "health": 3.5, "business": 5.5, "growth": 4.0,
                "family": 3.0, "competition": 5.5, "money": 4.5
            },
            "अनुराधा (Anuradha: アヌラーダ)": {
                "relation": 4.0, "health": 4.0, "business": 4.0, "growth": 4.5,
                "family": 4.0, "competition": 4.0, "money": 4.0
            },
            "ज्येष्ठा (Jyeshtha: ジェーシュター)": {
                "relation": 2.0, "health": 2.5, "business": 4.5, "growth": 3.0,
                "family": 2.5, "competition": 5.0, "money": 3.5
            },
            "मूल (Mula: ムーラ)": {
                "relation": 1.5, "health": 2.0, "business": 4.0, "growth": 2.5,
                "family": 2.0, "competition": 4.5, "money": 3.0
            },
            "पुर्वाषाढ़ा (Purva Ashadha: プルヴァ・アーシャーダ)": {
                "relation": 2.5, "health": 3.0, "business": 4.0, "growth": 3.5,
                "family": 2.5, "competition": 4.5, "money": 3.5
            },
            "उत्तराषाढ़ा (Uttara Ashadha: ウッタラ・アーシャーダ)": {
                "relation": 3.5, "health": 3.5, "business": 3.5, "growth": 4.0,
                "family": 3.5, "competition": 3.5, "money": 4.0
            },
            "श्रावण (Shravana: シュラヴァナ)": {
                "relation": 4.0, "health": 4.0, "business": 3.5, "growth": 4.5,
                "family": 4.0, "competition": 3.0, "money": 4.0
            },
            "धनिष्ठा (Dhanishta: ダニシュター)": {
                "relation": 3.0, "health": 3.5, "business": 4.5, "growth": 4.0,
                "family": 3.0, "competition": 5.0, "money": 5.0
            },
            "शतभिषा (Shatabhisha: シャタビーシャ)": {
                "relation": 2.5, "health": 4.0, "business": 3.5, "growth": 4.5,
                "family": 2.5, "competition": 3.5, "money": 4.0
            },
            "पूर्वभाद्रपदा (Purva Bhadrapada: プルヴァ・バードラパダー)": {
                "relation": 2.0, "health": 3.0, "business": 4.5, "growth": 3.5,
                "family": 2.5, "competition": 5.0, "money": 4.0
            },
            "उत्तरभाद्रपदा (Uttara Bhadrapada: ウッタラ・バードラパダー)": {
                "relation": 3.0, "health": 3.5, "business": 4.5, "growth": 4.0,
                "family": 3.0, "competition": 4.5, "money": 4.0
            },
            "रेवती (Revati: レヴァティ)": {
                "relation": 4.0, "health": 3.5, "business": 3.5, "growth": 4.0,
                "family": 4.0, "competition": 3.0, "money": 4.0
            }
        }

        # パダによる補正（変動幅拡大）
        pada_correction = {
            1: {
                "relation": 0.0, "health": 0.3, "business": -0.2, "growth": 0.4,
                "family": -0.2, "competition": 0.3, "money": 0.2
            },
            2: {
                "relation": 0.2, "health": 0.2, "business": 0.6, "growth": 0.3,
                "family": 0.1, "competition": 0.6, "money": 0.3
            },
            3: {
                "relation": -0.2, "health": 0.0, "business": 0.4, "growth": 0.2,
                "family": 0.2, "competition": -0.2, "money": 0.3
            },
            4: {
                "relation": 0.3, "health": -0.2, "business": 0.2, "growth": 0.0,
                "family": 0.3, "competition": 0.1, "money": 0.2
            }
        }

        # 基本スコアにパダ補正を適用
        base = base_scores.get(nakshatra_name, 
                              {
                                  "relation": 3.0, "health": 3.0, "business": 3.0, "growth": 3.0,
                                  "family": 3.0, "competition": 3.0, "money": 3.0
                              })

        correction = pada_correction.get(pada, {k: 0.0 for k in base.keys()})

        # スコア範囲を0.0-6.0に拡張
        return {k: max(0.0, min(6.0, base[k] + correction[k])) for k in base.keys()}

```

D先生： “ここが面白い！？中身は数字ばかりじゃないですか・・・。”

QEU:FOUNDER ： “この**パラメタばかりのメソッド（関数）群**について、ちょっと覚えていてください。さらに続きます。”

```python

    def calculate_dasha(self, birth_datetime: datetime, ayanamsa_value: float) -> Dict[str, Any]:
        """ダシャーを計算"""
        logger.info("दशा (Dasha: 惑星周期)計算を開始")
        
        try:
            # 月の位置を計算
            birth_datetime_utc = birth_datetime.astimezone(pytz.utc)
            t = self.ts.utc(
                birth_datetime_utc.year, 
                birth_datetime_utc.month, 
                birth_datetime_utc.day,
                birth_datetime_utc.hour, 
                birth_datetime_utc.minute, 
                birth_datetime_utc.second
            )
            
            earth = self.ephemeris['earth']
            moon = self.ephemeris['moon']
            astrometric = earth.at(t).observe(moon)
            apparent = astrometric.apparent()
            elon, _, _ = apparent.ecliptic_latlon()
            moon_longitude = elon.degrees % 360
            
            logger.info(f"月の黄経計算: {moon_longitude:.4f}度")
        except Exception as e:
            logger.error(f"月の位置計算に失敗: {str(e)}")
            # フォールバック計算
            moon_longitude = (birth_datetime.year * 0.9856 + birth_datetime.month * 29.1) % 360
        
        nakshatra_info = self._find_nakshatra(moon_longitude, ayanamsa_value)
        dasha_periods = self._get_vimshottari_dasha_periods()
        dasha_order = list(dasha_periods.keys())
        
        nakshatra_name = nakshatra_info["nakshatra"].split('(')[0].strip()
        
        # ナクシャトラからダシャーを決定
        nakshatra_dasha_map = {
            "अश्विनी": "केतु (Ketu: ケートゥ)",
            "भरणी": "केतु (Ketu: ケートゥ)",
            "कृत्तिका": "शुक्र (Shukra: 金星)",
            "रोहिणी": "शुक्र (Shukra: 金星)",
            "मृगशीर्ष": "सूर्य (Surya: 太陽)",
            "आर्द्रा": "सूर्य (Surya: 太陽)",
            "पुनर्वसु": "चन्द्र (Chandra: 月)",
            "पुष्य": "चन्द्र (Chandra: 月)",
            "आश्लेषा": "चन्द्र (Chandra: 月)",
            "मघा": "मंगल (Mangal: 火星)",
            "पूर्वफाल्गुनी": "मंगल (Mangal: 火星)",
            "उत्तरफाल्गुनी": "राहु (Rahu: ラーフ)",
            "हस्त": "राहु (Rahu: ラーフ)",
            "चित्रा": "राहु (Rahu: ラーフ)",
            "स्वाति": "राहु (Rahu: ラーフ)",
            "विशाखा": "बृहस्पति (Brihaspati: 木星)",
            "अनुराधा": "बृहस्पति (Brihaspati: 木星)",
            "ज्येष्ठा": "बृहस्पति (Brihaspati: 木星)",
            "मूल": "शनि (Shani: 土星)",
            "पुर्वाषाढ़ा": "शनि (Shani: 土星)",
            "उत्तराषाढ़ा": "शनि (Shani: 土星)",
            "श्रावण": "बुध (Budh: 水星)",
            "धनिष्ठा": "बुध (Budh: 水星)",
            "शतभिषा": "बुध (Budh: 水星)",
            "पूर्वभाद्रपदा": "बुध (Budh: 水星)",
            "उत्तरभाद्रपदा": "केतु (Ketu: ケートゥ)",
            "रेवती": "केतु (Ketu: ケートゥ)"
        }
        
        current_dasha = None
        for sanskrit_name, dasha in nakshatra_dasha_map.items():
            if nakshatra_name.startswith(sanskrit_name):
                current_dasha = dasha
                break
        
        if not current_dasha:
            logger.warning(f"ナクシャトラ '{nakshatra_name}' に対応するदशा (Dasha: 惑星周期)が見つかりません。デフォルトの月दशा (Dasha: 惑星周期)を使用します")
            current_dasha = "चन्द्र (Chandra: 月)"
        
        dasha_period = dasha_periods[current_dasha]
        total_nakshatra_deg = 13.3333
        
        # ナクシャトラ内での位置を計算
        relative_position = (
            nakshatra_info["corrected_longitude"] - 
            self.nakshatra_data[nakshatra_info["nakshatra_index"]]["start_deg"]
        ) / total_nakshatra_deg
        
        dasha_elapsed_ratio = relative_position
        total_dasha_years = 120.0  # Vimshottari Dashaの総期間
        total_dasha_days = total_dasha_years * 365.25
        dasha_elapsed_days = total_dasha_days * dasha_elapsed_ratio
        dasha_start = birth_datetime - timedelta(days=dasha_elapsed_days)
        
        # 現在のダシャーの経過時間と残り時間
        current_dasha_elapsed = (birth_datetime - dasha_start).total_seconds() / (365.25 * 24 * 3600)
        current_dasha_remaining = dasha_period - current_dasha_elapsed
        
        # サブダシャーを計算
        sub_periods = []
        dasha_index = dasha_order.index(current_dasha)
        
        for i in range(9):
            sub_dasha_index = (dasha_index + i) % 9
            sub_dasha = dasha_order[sub_dasha_index]
            sub_period_years = dasha_periods[sub_dasha]
            
            if i == 0:
                sub_start_ratio = dasha_elapsed_ratio
            else:
                prev_dasha_total = sum(
                    dasha_periods[dasha_order[(dasha_index + j) % 9]] 
                    for j in range(i)
                )
                sub_start_ratio = (dasha_elapsed_ratio * dasha_period + prev_dasha_total) / to-tal_dasha_years
            
            sub_start_days = total_dasha_days * sub_start_ratio
            sub_start = birth_datetime - timedelta(days=(total_dasha_days - sub_start_days))
            sub_end = sub_start + timedelta(days=sub_period_years * 365.25)
            
            sub_periods.append({
                "dasha": sub_dasha,
                "start_date": sub_start.isoformat(),
                "end_date": sub_end.isoformat(),
                "duration": sub_period_years,
                "start_year": sub_start.year,
                "end_year": sub_end.year
            })
            
            logger.info(f"サブदशा (Sub-Dasha: 次要惑星周期) {i+1}: {sub_dasha} ({sub_start.year}-{sub_end.year})")
        
        return {
            "current_dasha": current_dasha,
            "dasha_period": dasha_period,
            "current_dasha_start": dasha_start.isoformat(),
            "current_dasha_end": (dasha_start + timedelta(days=dasha_period * 365.25)).isoformat(),
            "current_dasha_elapsed": round(current_dasha_elapsed, 1),
            "current_dasha_remaining": round(current_dasha_remaining, 1),
            "sub_periods": sub_periods,
            "nakshatra": nakshatra_info["nakshatra"],
            "nakshatra_index": nakshatra_info["nakshatra_index"],
            "pada": nakshatra_info["pada"],
            "pada_index": nakshatra_info["pada_index"],
            "pada_position": nakshatra_info["pada_position"],
            "moon_longitude": moon_longitude,
            "corrected_longitude": nakshatra_info["corrected_longitude"],
            "dasha_elapsed_ratio": dasha_elapsed_ratio
        }
    
    def calculate_fortune_scores(self, current_dasha: Dict[str, Any]) -> Dict[str, float]:
        """運勢スコアを計算（0.5-5.5の範囲）"""
        logger.info("वित्त भाग्य (Vitta Bhagya: 運勢)スコアを計算中")
        
        # ダシャースコアを取得
        current_dasha_name = current_dasha.get("current_dasha", "")
        dasha_scores = self._get_dasha_scores(current_dasha_name)
        logger.debug(f"ダシャー: {current_dasha_name}, ダシャースコア: {dasha_scores}")
        
        # ナクシャトラスコアを取得
        nakshatra_name = current_dasha.get("nakshatra", "")
        pada_index = current_dasha.get("pada_index", 0) + 1  # 1-based index for Pada
        nakshatra_scores = self._get_nakshatra_scores(nakshatra_name, pada_index)
        logger.debug(f"ナクシャトラ: {nakshatra_name}, パダ: {pada_index}, ナクシャトラスコア: {nakshatra_scores}")
        
        # ダシャーとナクシャトラのスコアを平均化
        combined_scores = {}
        for category in dasha_scores.keys():
            combined_score = (dasha_scores[category] + nakshatra_scores[category]) / 2
            # スコアを0.5-5.5の範囲に制限
            combined_scores[category] = max(0.5, min(5.5, combined_score))
        
        logger.debug(f"総合スコア: {combined_scores}")
        logger.info(f"वित्त भाग्य (Vitta Bhagya: 運勢)スコア計算完了: {combined_scores}")
        return combined_scores
    
    def calculate_fortune_trend(self, birth_datetime: datetime, end_year: int, ayanamsa_value: float) -> Dict[str, List[Tuple[int, float]]]:
        """運勢トレンドを計算（5年ごと）"""
        logger.info(f"運勢トレンドを計算中: {birth_datetime.year}年から{end_year}年まで")
        
        categories = ["relation", "health", "business", "growth", "family", "competition", "money"]
        fortune_trend = {category: [] for category in categories}
        
        for year in range(birth_datetime.year, end_year + 1, 5):
            try:
                target_datetime = datetime(year, 1, 1, 0, 0, 0, tzinfo=birth_datetime.tzinfo)
                current_dasha = self.calculate_dasha(target_datetime, ayanamsa_value)
                fortune_scores = self.calculate_fortune_scores(current_dasha)
                
                for category in categories:
                    fortune_trend[category].append((year, fortune_scores[category]))
                
                logger.debug(f"{year}年の運勢計算完了: {fortune_scores}")
                self._print_yearly_fortune_evaluation(year, fortune_scores)
            except Exception as e:
                logger.error(f"{year}年の運勢計算に失敗: {str(e)}")
                if year == birth_datetime.year:
                    default_score = 3.0
                    for category in categories:
                        fortune_trend[category].append((year, default_score))
                else:
                    for category in categories:
                        if fortune_trend[category]:
                            last_score = fortune_trend[category][-1][1]
                            fortune_trend[category].append((year, last_score))
                        else:
                            fortune_trend[category].append((year, 3.0))
        
        return fortune_trend
    
    def _print_yearly_fortune_evaluation(self, year: int, fortune_scores: Dict[str, float]):
        """5年ごとの運勢評価を出力"""
        print(f"{'='*50}")
        print(f"運勢評価: {year}年")
        print(f"{'='*50}")
        
        categories_info = {
            "money": {
                "name": "お金",
                "positive": "給料アップ、臨時収入、財産の蓄積",
                "negative": "給料ダウン、財産蓄積につながらない臨時支出、財産の紛失、破壊、売却"
            },
            "relation": {
                "name": "人間関係",
                "positive": "コミュニケーションのレベルアップ、コミュニケーションの深化、満足度アップ",
                "negative": "コミュニケーションのレベルダウン、コミュニケーションの淡化、満足度ダウン"
            },
            "health": {
                "name": "健康",
                "positive": "身体的成長、身体・精神的安定",
                "negative": "身体的成長、身体・精神的不安定、病気、ケガ、不安、鬱"
            },
            "business": {
                "name": "事業",
                "positive": "事業を通じた成功、自己実現の達成、名声の獲得",
                "negative": "事業を通じた失敗、挫折、名声の失墜、訴訟"
            },
            "growth": {
                "name": "成長",
                "positive": "知識の獲得、能力の獲得と発揮、スキルの獲得と発揮",
                "negative": "知識の獲得する機会がない、能力を獲得できない・発揮できない、スキルの獲得できない・発揮できない"
            },
            "family": {
                "name": "家族",
                "positive": "自身の家庭に対する満足度向上、家庭の成長、家庭メンバーの幸福度向上",
                "negative": "自身の家庭に対する満足度低下、家庭の成長の阻害、家庭メンバーの幸福度低下"
            },
            "competition": {
                "name": "競争",
                "positive": "競争があり、その競争に優勢である",
                "negative": "競争があり、その競争に劣勢である"
            }
        }
        
        for category, info in categories_info.items():
            score_5scale = fortune_scores[category]
            score_11point = convert_to_11point_scale(score_5scale, category)
            label = get_score_label(score_11point)
            
            if category == "competition":
                if score_11point == 0:
                    comment = "競争がない"
                elif score_11point > 0:
                    comment = f"競争があり、その競争に優勢である（{label}）"
                else:
                    comment = f"競争があり、その競争に劣勢である（{label}）"
            else:
                if score_11point > 0:
                    comment = f"[+] {info['positive']}（{label}）"
                elif score_11point < 0:
                    comment = f"[-] {info['negative']}（{label}）"
                else:
                    comment = f"[ ] 通常の状態（{label}）"
            
            print(f"{info['name']}: {comment}")
        
        print(f"{'='*50}")
    
    def calculate_nakshatra_influences(self, birth_datetime: datetime, end_year: int, ayanamsa_value: float) -> Dict[int, Dict[str, str]]:
        """ナクシャトラの影響を計算（5年ごと）"""
        logger.info(f"ナクシャトラ影響を計算中: {birth_datetime.year}年から{end_year}年まで")
        nakshatra_influences = {}
        
        for year in range(birth_datetime.year, end_year + 1, 5):
            try:
                target_datetime = datetime(year, 1, 1, 0, 0, 0, tzinfo=birth_datetime.tzinfo)
                target_utc = target_datetime.astimezone(pytz.utc)
                
                t = self.ts.utc(
                    target_utc.year, target_utc.month, target_utc.day,
                    target_utc.hour, target_utc.minute, target_utc.second
                )
                
                earth = self.ephemeris['earth']
                moon = self.ephemeris['moon']
                astrometric = earth.at(t).observe(moon)
                apparent = astrometric.apparent()
                elon, _, _ = apparent.ecliptic_latlon()
                
                moon_longitude = elon.degrees % 360
                nakshatra_info = self._find_nakshatra(moon_longitude, ayanamsa_value)
                
                nakshatra_influences[year] = {
                    "nakshatra": nakshatra_info["nakshatra"],
                    "pada": nakshatra_info["pada"],
                    "characteristics": nakshatra_info["pada_characteristics"],
                    "moon_longitude": moon_longitude,
                    "corrected_longitude": nakshatra_info["corrected_longitude"]
                }
                
                logger.debug(f"{year}年: {nakshatra_info['nakshatra']} (パダ: {nakshatra_info['pada']})")
            except Exception as e:
                logger.warning(f"{year}年のナクシャトラ計算に失敗: {str(e)}")
                nakshatra_influences[year] = {
                    "nakshatra": "未定義",
                    "pada": "未定義",
                    "characteristics": "計算エラー",
                    "moon_longitude": None,
                    "corrected_longitude": None
                }
        
        return nakshatra_influences
    
    def generate_fortune_trend_graph(self, fortune_trend: Dict[str, List[Tuple[int, float]]], 
                                    filename: str, full_name: str, birth_year: int, end_year: int) -> str:
        """運勢トレンドグラフを生成"""
        logger.info(f"運勢トレンドグラフを生成: {filename}")
        
        plt.figure(figsize=(16, 10))
        
        categories = ["relation", "health", "business", "growth", "family", "competition", "money"]
        category_names = {
            "relation": "人間関係",
            "health": "健康",
            "business": "事業",
            "growth": "成長",
            "family": "家族",
            "competition": "競争",
            "money": "お金"
        }
        
        colors = {
            "relation": "#1f77b4",
            "health": "#ff7f0e",
            "business": "#2ca02c",
            "growth": "#d62728",
            "family": "#9467bd",
            "competition": "#8c564b",
            "money": "#e377c2"
        }
        
        markers = {
            "relation": "o",
            "health": "s",
            "business": "^",
            "growth": "D",
            "family": "v",
            "competition": "p",
            "money": "*"
        }
        
        for category in categories:
            if category in fortune_trend and fortune_trend[category]:
                years = [point[0] for point in fortune_trend[category]]
                scores_11point = [
                    convert_to_11point_scale(point[1], category) 
                    for point in fortune_trend[category]
                ]
                
                plt.plot(
                    years, scores_11point,
                    marker=markers[category],
                    markersize=8,
                    linestyle='-',
                    linewidth=2,
                    color=colors[category],
                    label=category_names[category]
                )
        
        plt.axhline(y=0, color='gray', linestyle='-', alpha=0.3)
        plt.grid(True, linestyle='--', alpha=0.7)
        plt.title(f"{full_name} の運勢トレンド (5年ごと)", fontsize=16)
        plt.xlabel('年', fontsize=12)
        plt.ylabel('運勢スコア (11段階評価)', fontsize=12)
        plt.xticks(range(birth_year, end_year + 1, 5), rotation=45)
        plt.yticks(range(-5, 6))
        plt.legend(loc='best', fontsize=10)
        plt.tight_layout()
        
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        plt.close()
        
        logger.info(f"グラフを保存: {filename}")
        return filename

def calculate_and_generate_graph(full_name: str, birth_date: datetime, birth_place: str, end_year: int) -> Dict[str, Any]:
    """ナクシャトラに基づいた運勢計算とグラフ生成を実行する関数。
    
    Args:
        full_name (str): フルネーム
        birth_date (datetime): 生年月日時 (タイムゾーン情報付き)
        birth_place (str): 出生地
        end_year (int): 計算終了年
    
    Returns:
        Dict[str, Any]: 計算結果と生成されたファイル名を含む辞書
    """
    logger.info("=== 運勢計算処理を開始 ===")
    logger.info(f"対象者: {full_name}")
    logger.info(f"出生: {birth_date} ({birth_place})")
    logger.info(f"対象期間: {birth_date.year}年 - {end_year}年")
    
    if not MAIN_DATA['nakshatra_data'] or not MAIN_DATA['locations']:
        logger.error("必要なJSONデータがロードされていません。プログラムを終了します。")
        raise RuntimeError("必要なJSONデータがロードされていません")
    
    analyzer = VedicAstrologyAnalyzer()
    locations = analyzer.locations
    
    if birth_place in locations:
        birth_place_data = locations[birth_place]
        logger.info(f"出生地データ取得: {birth_place} (緯度: {birth_place_data['latitude']}, 経度: {birth_place_data['longitude']}, タイムゾーン: {birth_place_data['timezone']})")
    else:
        birth_place_data = {"latitude": 35.6895, "longitude": 139.6917, "timezone": "Asia/Tokyo"}
        logger.warning(f"出生地 '{birth_place}' のデータが見つかりません。デフォルトの東京を使用します")
    
    # タイムゾーンの処理
    if birth_date.tzinfo is None:
        tz = pytz.timezone(birth_place_data['timezone'])
        birth_datetime = tz.localize(birth_date)
    else:
        birth_datetime = birth_date
    
    # Ayanamsaの計算
    ayanamsa_value = analyzer._calculate_lahiri_ayanamsa(birth_datetime)
    
    # ダシャーの計算
    current_dasha = analyzer.calculate_dasha(birth_datetime, ayanamsa_value)
    
    # 運勢スコアの計算
    fortune_scores = analyzer.calculate_fortune_scores(current_dasha)
    
    # 運勢トレンドの計算
    fortune_trend = analyzer.calculate_fortune_trend(birth_datetime, end_year, ayanamsa_value)
    
    # ナクシャトラ影響の計算
    nakshatra_influences = analyzer.calculate_nakshatra_influences(birth_datetime, end_year, aya-namsa_value)
    
    # グラフファイル名の作成
    name_slug = re.sub(r'[^a-zA-Z0-9_]', '_', full_name.lower())
    fortune_trend_graph_filename = f"{name_slug}_nakshatra_fortune_trend.png"
    
    # グラフの生成
    graph_path = analyzer.generate_fortune_trend_graph(
        fortune_trend,
        fortune_trend_graph_filename,
        full_name,
        birth_datetime.year,
        end_year
    )
    
    logger.info("=== 運勢計算処理が完了 ===")
    
    return {
        "fortune_trend": fortune_trend,
        "nakshatra_influences": nakshatra_influences,
        "fortune_trend_graph": graph_path,
        "current_dasha": current_dasha,
        "fortune_scores": fortune_scores,
        "birth_datetime": birth_datetime,
        "ayanamsa_value": ayanamsa_value
    }

if __name__ == "__main__":
    # Steve Jobsの例
    full_name = "Steve Jobs"
    birth_date = datetime(1955, 2, 24, 19, 0, 0)
    birth_place = "ロサンゼルス"
    end_year = 2012
    
    # タイムゾーンの設定
    tz = pytz.timezone("America/Los_Angeles")
    birth_datetime = tz.localize(birth_date)
    
    # 運勢計算とグラフ生成
    result = calculate_and_generate_graph(full_name, birth_datetime, birth_place, end_year)
    
    # 結果の表示
    print("=== 運勢計算結果 ===")
    print(f"運勢トレンドグラフ: {result['fortune_trend_graph']}")
    print(f"出生時刻 (UTC): {result['birth_datetime']}")
    print(f"Ayanamsa値: {result['ayanamsa_value']:.4f}度")
    print(f"出生ナクシャトラ: {result['current_dasha']['nakshatra']}")
    print(f"パダ: {result['current_dasha']['pada']}")
    print(f"現在のダシャー: {result['current_dasha']['current_dasha']} (残り: {re-sult['current_dasha']['current_dasha_remaining']}年)")
    
    print("運勢スコア:")
    category_names = {
        "relation": "人間関係",
        "health": "健康",
        "business": "仕事・事業",
        "growth": "成長",
        "family": "家族",
        "competition": "競争",
        "money": "金銭・財産"
    }
    
    for category, score in result['fortune_scores'].items():
        score_11point = convert_to_11point_scale(score, category)
        label = get_score_label(score_11point)
        print(f" - {category_names[category]}: {score_11point} ({label})")
    
    print("運勢トレンドデータ (一部):")
    for category, data in list(result['fortune_trend'].items())[:2]:
        converted_data = [
            (y, convert_to_11point_scale(s, category)) 
            for y, s in data[:3]
        ]
        print(f" {category_names[category]}: {converted_data}...")
    
    print("ナクシャトラ影響データ (一部):")
    sample_years = list(result['nakshatra_influences'].keys())[:3]
    for year in sample_years:
        info = result['nakshatra_influences'][year]
        print(f" {year}年: {info['nakshatra']} (パダ: {info['pada']})")

```

QEU:FOUNDER ： “インド占星術の独立したプログラムになりました。だから、運勢の解説も充実したものになりました。”

![imageINDS2-42-3](/2025-08-17-QEUR23_INDHS42/imageINDS2-42-3.jpg) 

D先生： “肝心の運勢グラフは？”

QEU:FOUNDER ： “DEEPSEEKの事例から、見てみましょう。”

![imageINDS2-42-4](/2025-08-17-QEUR23_INDHS42/imageINDS2-42-4.jpg) 

D先生：“えっ！？1975年から1985年って・・・。”

[![MOVIE1](http://img.youtube.com/vi/ErwS24cBZPc/0.jpg)](http://www.youtube.com/watch?v=ErwS24cBZPc "4K Restoration: 1984 Super Bowl APPLE MACINTOSH Ad by Ridley Scott")

D先生：“たしかに、あれはすさまじくすごかった。それ以外の時期の運勢スコアについては、どうも納得がいかんなあ・・・。”

QEU:FOUNDER ： “ちなみに、これはDEEPSEEKで当てはめをした結果です。”

**(プロンプト)**

```python

以下のプログラムを実行してみました。OUTPUTを見てください。1975年と1980年の事業運は3となっており、すべての運勢が全体的に低い。
とくに競争運が低すぎます。Steve Jobsの運勢をwikipediaから参照し、適切な運勢の変動になるべく合わせてください。
変更するのは、運勢のパラメタだけです。他のロジックを変えないでください。
また、運勢の変動は+5（大吉）～-5(大凶)の範囲なので、変動の範囲をもっと大きくとってください。
もう一度強調します。今回のテーマは運勢パラメタの最適化です。改善されたPythonプログラムを作成してください。
PROGRAM```

# 以下プログラム

```

```

QEU:FOUNDER ： “もともとの運勢のスコアが低すぎたので、AIに調整を頼んだのです。ちなみに、DEEPSEEKでやってみたら、もともとの運勢とほとんど変わらなかったんです。”

D先生：“他のAIでやってみましたか？”

QEU:FOUNDER ： “次は、QWENでやってみましょう。”

![imageINDS2-42-5](/2025-08-17-QEUR23_INDHS42/imageINDS2-42-5.jpg) 

QEU:FOUNDER ： “ちょっとだけ、納得性が良くなったでしょう？”

D先生：“そうですね、少しだけ良くなりました。DEEPSEEKの当てはめでは、競争の項目のスコアが低すぎたので気になっていました。ここでは、この点が若干ですが改善されています。しかし、これでも全然納得いかないです。”

QEU:FOUNDER ： “最後に、GROKで当てはめてみましょう！ドン！！”

![imageINDS2-42-6](/2025-08-17-QEUR23_INDHS42/imageINDS2-42-6.jpg) 

D先生： “うへぇ・・・。強力に当てはめましたね。これならば、私のイメージに合います。・・・だけど、どうなんだろう。このパラメータって、他の人には使い物になるんだろうか・・・。”

QEU:FOUNDER ： “さっきのプロンプトを思い出してください。一人だけを例に出して当てはめたでしょう？”

D先生： “そりゃ、**「1000人ぐらいを取り出した当てはめ」**ができれば、すごいことになります。”

![imageINDS2-42-7](/2025-08-17-QEUR23_INDHS42/imageINDS2-42-7.jpg) 

D先生： “それが可能になれば、LLMの占い能力は、占い師を超えるんじゃないですか？”

QEU:FOUNDER ： “GPT-6レベルになると、**そういうこと（最小二乗法に似た当てはめ）ができるかもしれません**。それにしても、今回の知見は、**AIでもパラメタ設計(最適化)**ができるということです。”

D先生： “SN比もできるかな？”

QEU:FOUNDER ： “将来的には、SN比みたいなつまらないものは、プロセスや製品の最適化には不要です。**AIに対して「ロバストなモノを作ってください」と言えばいいだけ**ですから・・・。ここで注意ですが、実現するのはGPT-6以降の話ですがね。”

![imageINDS2-42-8](/2025-08-17-QEUR23_INDHS42/imageINDS2-42-8.jpg) 

D先生：“くだらない**「昭和の幻想（ノスタルジア）の押し売り」**は、もうやめた方がいいですね。”

![imageINDS2-42-9](/2025-08-17-QEUR23_INDHS42/imageINDS2-42-9.jpg) 

QEU:FOUNDER ： “おじいさんが「ワシは盆栽がわりに趣味でやっています」というのだったら別にいいです。もし、企業内で窓際講師をしているんだったら、**教壇の裏に隠れていましょう。無事に退官するまで・・・。**とにかく、これ以上若い人をまきこまないで欲しいです。”

[![MOVIE2](http://img.youtube.com/vi/7dRjbwZhtiA/0.jpg)](http://www.youtube.com/watch?v=7dRjbwZhtiA "悪いことは言わん。つべこべ言わず、日本の政治家は全員、今日の日経新聞を買って25面の「経済教室」を読め！:15分朝刊チェック 2025年8月13日")

QEU:FOUNDER ： “皆が貧乏になったのは、アナタたちが原因です。ほんのちょっとですがね。”


## ～ まとめ ～

QEU:FOUNDER ： “いやあ、これはひどいなあ。何とかしないと・・・。”

![imageINDS2-42-10](/2025-08-17-QEUR23_INDHS42/imageINDS2-42-10.jpg) 

C部長：“それでも、アレ（↓）を推し進めたい人がいます。”

![imageINDS2-42-11](/2025-08-17-QEUR23_INDHS42/imageINDS2-42-11.jpg) 

C部長：“こんな人たちかもね。しらんけど・・・。”

![imageINDS2-42-12](/2025-08-17-QEUR23_INDHS42/imageINDS2-42-12.jpg) 

QEU:FOUNDER ： “まだ信じている人がいるのが驚きです。**すでに社会実験の結果がでた**のに・・・。”

[![MOVIE3](http://img.youtube.com/vi/FCc8cojW3ZU/0.jpg)](http://www.youtube.com/watch?v=FCc8cojW3ZU "田内学×宮台真司：人を幸せにする経済とは")

D先生：“ずっと昔の議論ですが、経済の結局は、この結論（↑）につきますね。それにしても、今後は大丈夫かなあ・・・。”

![imageINDS2-42-13](/2025-08-17-QEUR23_INDHS42/imageINDS2-42-13.jpg) 

D先生：“十数年間、国を挙げて**差別と搾取を奨励する以外の何もやらなかったツケ**がきました。”

C部長：“株価のランキングがから微妙なところですが、**来年で5位以内なら御の字**というのは、大胆過ぎる仮説じゃないですか？”

![imageINDS2-42-14](/2025-08-17-QEUR23_INDHS42/imageINDS2-42-14.jpg) 

D先生：“J国は、EVで大負けしていますが、**今の潮流はEVの段階を越えてしまっています**。運転の自動化がどこまで進むか。もし、この技術の実用化がどんどん進むと、**自動車業界が本当に「ガラガラポン」になってしまいます**。”

![imageINDS2-42-15](/2025-08-17-QEUR23_INDHS42/imageINDS2-42-15.jpg) 

QEU:FOUNDER ： “ここまで来たら、もう、全力でお祈りするしかないのかもね。”

![imageINDS2-42-16](/2025-08-17-QEUR23_INDHS42/imageINDS2-42-16.jpg) 

C部長：”これ以上、貧乏になりませんように・・・。”

