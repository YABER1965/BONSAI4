---
title: QEUR23_INDHS40 - 閑話休題～ヴェーダ数秘術をやってみる(併用法NO1)   
date: 2025-08-14
tags: ["QEUシステム", "メトリックス", "Python言語", "Unsloth", "LLM", "データセット", "BONSAI", "LangGraph"]
excerpt: あたらしいLLMの学習体系を確立する
---

## QEUR23_INDHS40 - 閑話休題～ヴェーダ数秘術をやってみる(併用法NO1)    

## ～  はたして、ちゃんとシンクロできるのか？ ～

QEU:FOUNDER ： “今回から、ヴェーダ数秘術をやります。”

D先生： “たしか、これはインド発祥ですよね？・・・であれば、（インド）占星術の方が、占いとしては精度がいいんじゃないんですか？”

![imageINDS2-40-1](/2025-08-14-QEUR23_INDHS40/imageINDS2-40-1.jpg) 

QEU:FOUNDER ： “最近、我々は、**「数秘術と占星術を併用すると、（占い）精度が上がるのか？」**をやっているでしょ？カバラ数秘術では、うまく占星術に合わないです。その点、ヴェーダ数秘術は占星術と兄弟関係ですから・・・。”

D先生： “どういう風に？”

![imageINDS2-40-2](/2025-08-14-QEUR23_INDHS40/imageINDS2-40-2.jpg) 

QEU:FOUNDER ： “こんな風（↑）に・・・。”

D先生：“**数字が惑星とリンクする**？これはすごい！！今回は、またこの名コンビ（↓）を占うのですか？”

![imageINDS2-40-3](/2025-08-14-QEUR23_INDHS40/imageINDS2-40-3.jpg) 

QEU:FOUNDER ： “こんな真打は、プログラムが完成した後にやります。ヴェーダ数秘術はマイナーなのかな？わからない部分が多すぎるのです。なにしろAIによって、手順と解釈について言うことが違うんです。流派があるのはわかるが、一体なにがほんとうなのやら・・・。小生としては、**（占い）結果が合うのであれば、（差異は）別にどうでもいい**んですがね。それでは、プログラムをドン！！かなり長いよ・・・。”

# **要件定義書：ヴェーダ数秘術分析システム**

## **1. システム概要**

### **1.1 目的**
本システムは、ヴェーダ数秘術とインド占星術に基づき、ユーザーの生年月日、名前、出生地を入力として、誕生数、運命数、ナクシャトラ、ダシャー周期、運勢スコア、運勢トレンドを計算し、詳細な分析レポートと視覚的なグラフを生成する。また、DeepSeek API を活用して専門的な解釈を提供し、ユーザーに実践的なアドバイスを提示する。システムは Jupyter Notebook 環境での実行を前提とし、日本語の文字化け問題を解決するために `japanize_matplotlib` を使用する。

### **1.2 システムの範囲**
- **入力**：ユーザーの名前、生年月日、出生地（都市名）、任意のオリジナルスクリプト名。
- **処理**：
  - 誕生数と運命数の計算。
  - 月の位置に基づくナクシャトラとダシャー周期の計算。
  - 運勢スコアおよび長期的な運勢トレンドの計算。
  - 日本語によるレポート生成。
  - 運勢トレンドのグラフ生成（日本語対応）。
  - DeepSeek API を使用した専門的解釈の生成。
- **出力**：
  - テキスト形式の分析レポート。
  - 運勢トレンドグラフ（PNG形式）。
  - LLM（大規模言語モデル）による詳細解釈。

### **1.3 利用者**
- ヴェーダ数秘術やインド占星術に興味のある個人ユーザー。
- 占星術研究者や開発者（Jupyter Notebook を使用）。
- 日本語を主要言語とするユーザー。

## **2. 機能要件**

### **2.1 ユーザー入力処理**
- **機能**：ユーザーの入力（名前、生年月日、出生地など）を受け取り、妥当性を検証する。
- **詳細**：
  - 入力項目：
    - フルネーム（文字列、必須）。
    - 生年月日（`datetime.date` 形式、必須）。
    - 出生地（都市名、必須：ロサンゼルス、東京、ニューヨーク、ロンドン、デリーのいずれか）。
    - オリジナルスクリプト名（文字列、オプション）。
    - グラフの終了年（整数、デフォルト：2030）。
    - LLM 解釈の対象年（整数、デフォルト：2011）。
  - 出生地のマッピング：
    - 都市名から緯度、経度、タイムゾーンを検索（固定リストを使用）。
    - ファジーマッチングで大文字小文字の違いを許容。
  - エラー処理：
    - 出生地が見つからない場合、エラーメッセージをログに記録し、状態にエラーを設定。

### **2.2 数秘術計算**
- **機能**：誕生数、運命数、ナクシャトラ、ダシャー周期を計算。
- **詳細**：
  - **誕生数**：
    - 生年月日の数字を合計し、1桁（1～9）に還元。
    - 例：1955-02-24 → 1+9+5+5+0+2+2+4 = 28 → 2+8 = 10 → 1+0 = 1。
  - **運命数**：
    - フルネームの各文字をカタパヤディシステムに基づき数値に変換、合計し、1桁に還元。
  - **ナクシャトラとダシャー周期**：
    - Skyfield ライブラリを使用して月の黄経を計算。
    - ナクシャトラとパダを特定（`nakshatra_data.json` を参照）。
    - ダシャー周期（主周期とサブ周期）を計算し、開始日、終了日、残り年数を算出。
  - エラー処理：
    - 計算エラーが発生した場合、代替計算（簡略化された月の位置計算）を使用。
    - エラーをログに記録し、状態にエラーを設定。

### **2.3 運勢スコアとトレンド計算**
- **機能**：現在の運勢スコアと将来の運勢トレンドを計算。
- **詳細**：
  - **運勢スコア**：
    - カテゴリ：金運、人間関係、健康、事業、成長、家族、競争。
    - 誕生数と現在のダシャー周期に基づき、加重平均でスコア（-5～+5）を計算。
  - **運勢トレンド**：
    - 指定された終了年（デフォルト：2030）まで、5年ごとの運勢スコアを計算。
    - 各カテゴリのスコアを時系列で記録。
  - エラー処理：
    - エラーが発生した場合、トレンドをゼロで埋めるか、直前の値を補完。

### **2.4 レポート生成**
- **機能**：分析結果を日本語でレポートとして生成。
- **詳細**：
  - **基本レポート**：
    - 誕生数、運命数、ナクシャトラ、ダシャー周期の詳細。
    - 運勢スコア（各カテゴリの評価と説明）。
    - 能力評価（キャリア適性）。
    - 健康リスクとアドバイス、幸運要素（色、宝石、金属、曜日、方角）。
  - **フォーマット**：
    - 日本語のテキスト形式。
    - 見出し、箇条書き、星マーク（★/☆）を使用した視覚的表現。
  - データソース：
    - `numerology_data.json`（誕生数・運命数の詳細）。
    - 計算結果（ナクシャトラ、ダシャー、運勢スコア）。

### **2.5 グラフ生成**
- **機能**：運勢トレンドを折れ線グラフとして生成。
- **詳細**：
  - グラフ内容：
    - X軸：年（5年ごと、開始年から終了年まで）。
    - Y軸：運勢スコア（-5～+5）。
    - 各カテゴリ（金運、人間関係など）を異なる色でプロット。
  - 日本語対応：
    - `japanize_matplotlib` を使用し、タイトル、軸ラベル、凡例を日本語で表示。
  - 出力：
    - PNGファイル（`Steve_Jobs_fortune_trend.png`）として保存。
    - Jupyter Notebook 内でインライン表示（`plt.show()`）。
  - エラー処理：
    - グラフ生成エラーをログに記録し、状態にエラーを設定。

### **2.6 LLM による専門的解釈**
- **機能**：DeepSeek API を使用して詳細な解釈を生成。
- **詳細**：
  - 入力データ：
    - 誕生数、運命数、ナクシャトラ、ダシャー周期、運勢スコア、能力評価。
  - 解釈内容：
    - カルマとダルマの観点（人生の目的と使命）。
    - 支配惑星の影響。
    - ダシャー周期の詳細解説。
    - 実践的なアドバイス。
    - 指定年（デフォルト：2011）までの運勢の見通し。
  - API 設定：
    - エンドポイント：`https://api.deepseek.com/v1`。
    - モデル：`deepseek-chat`。
    - API キーは環境変数 `DEEPSEEK_API_KEY` から取得。
  - エラー処理：
    - API エラー（モデル名無効、API キー無効など）をログに記録。
    - エラーメッセージをユーザーに返し、修正方法を提示。

### **2.7 ワークフロー管理**
- **機能**：LangGraph を使用して処理の流れを管理。
- **詳細**：
  - ノード：
    - ユーザー入力処理。
    - 数秘術計算。
    - 運勢トレンドグラフ生成。
    - LLM 解釈生成。
    - 結果表示。
  - エッジ：
    - 各ノードを順次実行（入力処理 → 計算 → グラフ → LLM → 表示）。
  - 状態管理：
    - `VedicNumerologyState`（TypedDict）で状態を管理。
    - エラー発生時は状態にエラーを記録し、処理を継続。

### **2.8 結果表示**
- **機能**：分析結果をコンソールに表示。
- **詳細**：
  - 基本レポート、LLM 解釈、グラフの状態を表示。
  - エラーが発生した場合、エラーメッセージを表示。
  - 日本語でフォーマットされたテキストを出力。

QEU:FOUNDER ： “おっと、間違って要件定義書を出してしまった（笑）。”

D先生：“あれ？インドの数秘術では、計算できる数の種類が2つしかないのですか？カバラでは、沢山あります。”

![imageINDS2-40-4](/2025-08-14-QEUR23_INDHS40/imageINDS2-40-4.jpg) 

QEU:FOUNDER ： “だから、今のところは「調査中・・・」としか言いようがないんです。それでは、改めてプログラムをドン！！”

```python
# ---
import os
import json
import logging
import tempfile
import shutil
import datetime
from enum import Enum
from typing import Dict, List, Any, Optional, TypedDict
from math import floor
import matplotlib.pyplot as plt
import numpy as np
from skyfield.api import load, utc
from openai import OpenAI
import japanize_matplotlib  # 日本語フォント対応

# Jupyter Notebookでのグラフ表示設定
%matplotlib inline

# 環境変数でエンコーディング設定
os.environ['PYTHONIOENCODING'] = 'utf-8'

# ロギングの設定
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class ErrorCode(Enum):
    INVALID_DATE = "INVALID_DATE"
    LOCATION_NOT_FOUND = "LOCATION_NOT_FOUND"
    CALCULATION_ERROR = "CALCULATION_ERROR"
    API_ERROR = "API_ERROR"
    EPHEMERIS_RANGE_ERROR = "EPHEMERIS_RANGE_ERROR"

class VedicNumerologyState(TypedDict):
    full_name: str
    birth_date: datetime.date
    birth_datetime: Optional[datetime.datetime]
    user_location: str
    original_name_script: Optional[str]
    latitude: Optional[float]
    longitude: Optional[float]
    timezone: Optional[str]
    vedic: Optional[Any]
    birth_number: Optional[int]
    destiny_number: Optional[int]
    dasha_info: Optional[Dict[str, Any]]
    fortune_scores: Optional[Dict[str, int]]
    fortune_trends: Optional[Dict[str, Any]]
    basic_report: Optional[str]
    langgraph_data: Optional[Dict[str, Any]]
    llm_interpretation: Optional[str]
    error: Optional[str]
    graph_end_year: Optional[int]
    llm_comment_year: Optional[int]
    graph_filename: Optional[str]

class VedicNumerology:
    def __init__(self):
        try:
            if not os.path.exists('numerology_data.json'):
                raise FileNotFoundError("numerology_data.jsonが見つかりません")
            if not os.path.exists('nakshatra_data.json'):
                raise FileNotFoundError("nakshatra_data.jsonが見つかりません")
            
            # JSONファイルをUTF-8エンコーディングで読み込む
            with open('numerology_data.json', 'r', encoding='utf-8') as f:
                self.numerology_data = json.load(f)
            with open('nakshatra_data.json', 'r', encoding='utf-8') as f:
                self.nakshatras = json.load(f)
            
            self.career_names = {
                "teacher_humanities_writer": "教師・人文系・ライター",
                "scientist_math_engineer": "科学者・数学者・エンジニア",
                "religious_leader_philosopher": "宗教家・哲学者",
                "office_worker_manager": "オフィスワーカー・マネージャー",
                "chef_artist": "シェフ・アーティスト",
                "entertainer_musician": "エンターテイナー・ミュージシャン",
                "executive_ceo": "経営者・CEO",
                "politician_civil_servant": "政治家・公務員"
            }
            self.dasha_periods = {
                "केतु (Ketu: ケートゥ)": 7,
                "शुक्र (Shukra: 金星)": 20,
                "सूर्य (Surya: 太陽)": 6,
                "चन्द्र (Chandra: 月)": 10,
                "मंगल (Mangal: 火星)": 7,
                "राहु (Rahu: ラーフ)": 18,
                "गुरु (Guru: 木星)": 16,
                "शनि (Shani: 土星)": 19,
                "बुध (Budh: 水星)": 17
            }
            self.ts = None
            self.ephemeris = None
            self._init_skyfield()
        except FileNotFoundError as e:
            logger.error(f"ファイル読み込みエラー: {str(e)}")
            raise
        except UnicodeDecodeError as e:
            logger.error(f"JSONファイルのデコードエラー: {str(e)}。UTF-8エンコーディングで保存されていることを確認してください。")
            raise
        except Exception as e:
            logger.error(f"VedicNumerology初期化エラー: {str(e)}")
            raise
    
    def _init_skyfield(self):
        try:
            self.temp_dir = tempfile.mkdtemp()
            load.directory = self.temp_dir
            logger.info("Ephemeris (de440s.bsp)をロード中...")
            self.ts = load.timescale(builtin=True)
            try:
                self.ephemeris = load('de440s.bsp')
                logger.info("Ephemerisのロードが完了しました")
            except Exception as e:
                logger.warning(f"de440s.bspのロードに失敗: {str(e)}")
                logger.info("代替としてde421.bspを使用します")
                self.ephemeris = load('de421.bsp')
        except Exception as e:
            logger.error(f"Ephemerisのロードに失敗: {str(e)}")
            raise
    
    def __del__(self):
        try:
            if hasattr(self, 'temp_dir') and os.path.exists(self.temp_dir):
                shutil.rmtree(self.temp_dir)
        except Exception as e:
            logger.warning(f"一時ディレクトリの削除に失敗: {str(e)}")
    
    def calculate_birth_number(self, birth_date: datetime.date) -> int:
        total = 0
        for char in str(birth_date):
            if char.isdigit():
                total += int(char)
        while total > 9:
            total = sum(int(digit) for digit in str(total))
        return total if total != 0 else 9
    
    def calculate_destiny_number(self, full_name: str) -> int:
        katapayadi_map = {
            'a': 1, 'k': 1, 'j': 1, 'h': 1,
            'i': 2, 'c': 2, 'g': 2, 'ṇ': 2,
            'u': 3, 'ṭ': 3, 'ḍ': 3, 'r': 3,
            'e': 4, 't': 4, 'd': 4, 'n': 4,
            'ṛ': 5, 'q': 5, 'ṣ': 5, 'l': 5,
            'o': 6, 'p': 6, 'b': 6, 'm': 6,
            'ā': 7, 'k': 7, 'j': 7, 'h': 7,
            'ī': 8, 'c': 8, 'g': 8, 'ñ': 8,
            'ū': 9, 'ṭ': 9, 'ḍ': 9, 'n': 9
        }
        total = 0
        for char in full_name.lower():
            if char in katapayadi_map:
                total += katapayadi_map[char]
        while total > 9:
            total = sum(int(digit) for digit in str(total))
        return total if total != 0 else 9

```

D先生：“ほお・・・。JSONで読む外部データがあるんですね。”

QEU:FOUNDER ： “数秘術の数字の属性などです。これらをプログラムに組み込むと長くなりますからね。”

![imageINDS2-40-5](/2025-08-14-QEUR23_INDHS40/imageINDS2-40-5.jpg) 

D先生：“この中身の晒しは？”

QEU:FOUNDER ： “これはAIで作りました。自分でAIに頼めば作れますよ。それでは、次にいきましょう。”

```python

    def calculate_moon_position(self, birth_datetime: datetime.datetime, 
                              latitude: float, longitude: float) -> float:
        try:
            birth_datetime = birth_datetime.replace(tzinfo=utc)
            earth = self.ephemeris['earth']
            moon = self.ephemeris['moon']
            ts = self.ts.utc(birth_datetime.year, birth_datetime.month, 
                            birth_datetime.day, birth_datetime.hour,
                            birth_datetime.minute, birth_datetime.second)
            astrometric = earth.at(ts).observe(moon)
            app_pos = astrometric.apparent()
            lat, lon, distance = app_pos.ecliptic_latlon()
            moon_longitude = lon.degrees % 360.0
            logger.info(f"月の位置計算成功: {moon_longitude:.4f}° (日付: {birth_datetime})")
            return moon_longitude
        except Exception as e:
            logger.error(f"月の位置計算エラー: {str(e)}")
            base_date = datetime.datetime(1900, 1, 1, tzinfo=utc)
            days_since_base = (birth_datetime - base_date).total_seconds() / 86400.0
            moon_longitude = (270.0 + days_since_base * 13.176358) % 360.0
            logger.warning(f"代替計算を使用: {moon_longitude:.4f}°")
            return moon_longitude
    
    def _find_nakshatra(self, moon_longitude: float) -> Dict[str, Any]:
        for nakshatra in self.nakshatras:
            if nakshatra["start_deg"] <= moon_longitude < nakshatra["end_deg"]:
                return nakshatra
        return self.nakshatras[0]
    
    def _find_pada(self, nakshatra: Dict[str, Any], moon_longitude: float) -> Dict[str, Any]:
        nakshatra_deg = moon_longitude - nakshatra["start_deg"]
        pada_size = 3.20
        pada_index = min(int(nakshatra_deg / pada_size), 3)
        return nakshatra["padas"][pada_index]
    
    def calculate_dasha_period(self, birth_datetime: datetime.datetime,
                             latitude: float, longitude: float) -> Dict[str, Any]:
        try:
            moon_longitude = self.calculate_moon_position(birth_datetime, latitude, longitude)
            nakshatra = self._find_nakshatra(moon_longitude)
            pada = self._find_pada(nakshatra, moon_longitude)
            degrees_into_nakshatra = moon_longitude - nakshatra["start_deg"]
            total_nakshatra_degrees = 13.20
            elapsed_ratio = degrees_into_nakshatra / total_nakshatra_degrees
            lords = list(self.dasha_periods.keys())
            dasha_index = (len(lords) - 1) % len(lords)
            dasha_lord = lords[dasha_index]
            total_cycle = sum(self.dasha_periods.values())
            dasha_period = self.dasha_periods[dasha_lord]
            remaining_years = dasha_period * (1 - elapsed_ratio)
            elapsed_years = dasha_period - remaining_years
            start_date = birth_datetime + datetime.timedelta(days=elapsed_years * 365.25)
            end_date = start_date + datetime.timedelta(days=dasha_period * 365.25)
            sub_periods = []
            start_index = 0
            for i, lord in enumerate(lords):
                if lord == dasha_lord:
                    start_index = i
                    break
            current_date = start_date
            for i in range(20):
                lord_index = (start_index + i) % len(lords)
                lord = lords[lord_index]
                sub_dasha_period = self.dasha_periods[lord] * self.dasha_periods[dasha_lord] / total_cycle
                end_date = current_date + datetime.timedelta(days=sub_dasha_period * 365.25)
                sub_periods.append({
                    "sub_dasha": lord,
                    "start_date": current_date,
                    "end_date": end_date,
                    "duration_years": sub_dasha_period
                })
                current_date = end_date
            return {
                "moon_position": moon_longitude,
                "nakshatra": nakshatra["name"],
                "nakshatra_ruler": nakshatra["ruler"],
                "nakshatra_pada": pada["name"],
                "nakshatra_pada_characteristics": pada["characteristics"],
                "current_dasha": dasha_lord,
                "current_dasha_start": start_date,
                "current_dasha_end": end_date,
                "current_dasha_remaining": remaining_years,
                "sub_periods": sub_periods
            }
        except Exception as e:
            logger.error(f"Dasha周期計算エラー: {str(e)}")
            raise
    
    def calculate_fortune_scores(self, birth_number: int, 
                               dasha_info: Dict[str, Any]) -> Dict[str, int]:
        try:
            birth_data = self.numerology_data[str(birth_number)]
            dasha_scores = {}
            current_dasha = dasha_info["current_dasha"]
            dasha_period = self.dasha_periods[current_dasha]
            dasha_scores = {
                "money": 2,
                "relation": 2,
                "health": 2,
                "business": 2,
                "growth": 2,
                "family": 2,
                "competition": 2
            }
            if "सूर्य (Surya: 太陽)" in current_dasha:
                dasha_scores["business"] = 3
                dasha_scores["competition"] = 3
            elif "चन्द्र (Chandra: 月)" in current_dasha:
                dasha_scores["relation"] = 3
                dasha_scores["family"] = 3
            elif "मंगल (Mangal: 火星)" in current_dasha:
                dasha_scores["competition"] = 4
                dasha_scores["business"] = 3
            elif "बुध (Budh: 水星)" in current_dasha:
                dasha_scores["business"] = 3
                dasha_scores["growth"] = 3
            elif "गुरु (Guru: 木星)" in current_dasha:
                dasha_scores["money"] = 3
                dasha_scores["growth"] = 4
            elif "शुक्र (Shukra: 金星)" in current_dasha:
                dasha_scores["relation"] = 4
                dasha_scores["money"] = 3
            elif "शनि (Shani: 土星)" in current_dasha:
                dasha_scores["growth"] = 3
                dasha_scores["health"] = 2
            elif "राहु (Rahu: ラーフ)" in current_dasha:
                dasha_scores["business"] = 4
                dasha_scores["competition"] = 4
            elif "केतु (Ketu: ケートゥ)" in current_dasha:
                dasha_scores["growth"] = 4
                dasha_scores["health"] = 3
            final_scores = {}
            categories = ["money", "relation", "health", "business", "growth", "family", "competition"]
            for category in categories:
                birth_score = birth_data["career_assessment"].get(
                    "executive_ceo" if category == "business" else
                    "teacher_humanities_writer" if category == "relation" else
                    "scientist_math_engineer" if category == "growth" else
                    "office_worker_manager", 3) - 1
                dasha_score = dasha_scores.get(category, 2)
                score = (birth_score * 0.7 + dasha_score * 0.3) * 1.25 - 5
                final_scores[category] = max(-5, min(5, int(round(score))))
            return final_scores
        except Exception as e:
            logger.error(f"運勢スコア計算エラー: {str(e)}")
            raise
    
    def calculate_fortune_trends(self, birth_number: int, birth_date: datetime.date,
                               latitude: float, longitude: float, end_year: int = 2030) -> Dict[str, Any]:
        try:
            start_year = birth_date.year
            end_year = min(end_year, start_year + 100)
            years = list(range(start_year, end_year + 1, 5))
            trends = {
                "money": [],
                "relation": [],
                "health": [],
                "business": [],
                "growth": [],
                "family": [],
                "competition": []
            }
            for year in years:
                test_date = datetime.datetime(year, 1, 1, 12, 0, 0)
                try:
                    moon_longitude = self.calculate_moon_position(test_date, latitude, longitude)
                    nakshatra = self._find_nakshatra(moon_longitude)
                    pada = self._find_pada(nakshatra, moon_longitude)
                    dasha_info = {
                        "moon_position": moon_longitude,
                        "nakshatra": nakshatra["name"],
                        "nakshatra_ruler": nakshatra["ruler"],
                        "nakshatra_pada": pada["name"],
                        "nakshatra_pada_characteristics": pada["characteristics"],
                        "current_dasha": nakshatra["ruler"],
                        "current_dasha_start": test_date,
                        "current_dasha_end": test_date,
                        "current_dasha_remaining": 0,
                        "sub_periods": []
                    }
                    fortune_scores = self.calculate_fortune_scores(birth_number, dasha_info)
                    for category in trends.keys():
                        trends[category].append(fortune_scores[category])
                except Exception as e:
                    logger.warning(f"年{year}のトレンド計算でエラー: {str(e)}")
                    if trends[list(trends.keys())[0]]:
                        for category in trends.keys():
                            trends[category].append(trends[category][-1])
                    else:
                        for category in trends.keys():
                            trends[category].append(0)
            return {
                "years": years,
                "trends": trends
            }
        except Exception as e:
            logger.error(f"運勢トレンド計算全体のエラー: {str(e)}")
            return {
                "years": [birth_date.year, birth_date.year + 5],
                "trends": {
                    "money": [0, 0],
                    "relation": [0, 0],
                    "health": [0, 0],
                    "business": [0, 0],
                    "growth": [0, 0],
                    "family": [0, 0],
                    "competition": [0, 0]
                }
            }
    
```

D先生： “このプログラムは、本場の（サンスクリット）文字が出ているので、雰囲気がイケてますね。しかし、このプログラム、運勢だけは（占星術の）ナクシャトラを使うんですね。ちなみに、今回は誰を占ったんですか？”

![imageINDS2-40-6](/2025-08-14-QEUR23_INDHS40/imageINDS2-40-6.jpg) 

QEU:FOUNDER ： “あとのユーザ定義でわかるが、この人（↑）です。”

D先生： “なるほど。そして、肝心の運勢は？”

![imageINDS2-40-7](/2025-08-14-QEUR23_INDHS40/imageINDS2-40-7.jpg) 

D先生： “う～ん・・・。これは、ちょっとおかしくないですか？”

QEU:FOUNDER ： “まだ改善が必要なんですよ・・・（笑）。”

D先生： “そう・・・、最初ですからね。それでは、まとめ段階に行きましょう。 “

```python

    def generate_basic_report(self, birth_number: int, destiny_number: int,
                            dasha_info: Dict[str, Any], fortune_scores: Dict[str, int],
                            full_name: str, original_script: str = None,
                            location_info: Dict[str, Any] = None) -> str:
        report = f"【{full_name} 様のヴェーダ数秘術分析結果】\n"
        report += "=" * 50 + "\n\n"
        birth_data = self.numerology_data[str(birth_number)]
        report += "【基本分析】\n"
        report += f"誕生数: {birth_number} ({birth_data['planet']})\n"
        report += f"- 強み: {', '.join(birth_data['strengths'])}\n"
        report += f"- 弱み: {', '.join(birth_data['weaknesses'])}\n"
        report += f"- 人生テーマ: {birth_data['life_themes']}\n\n"
        destiny_data = self.numerology_data[str(destiny_number)]
        report += f"運命数: {destiny_number} ({destiny_data['planet']})\n"
        report += f"- 人生の目的: {destiny_data['life_themes']}\n"
        report += f"- 幸運の色: {', '.join(destiny_data['lucky_colors'])}\n\n"
        report += "【ナクシャトラ分析】\n"
        report += f"- 月の位置: {dasha_info['moon_position']:.2f}°\n"
        report += f"- ナクシャトラ: {dasha_info['nakshatra']} ({dasha_info['nakshatra_ruler']})\n"
        report += f"- パダ: {dasha_info['nakshatra_pada']}\n"
        report += f"- 特性: {dasha_info['nakshatra_pada_characteristics']}\n\n"
        report += "【ダシャー周期分析】\n"
        report += f"- 現在のダシャー: {dasha_info['current_dasha']}\n"
        report += f"- 開始日: {dasha_info['current_dasha_start'].strftime('%Y-%m-%d')}\n"
        report += f"- 終了日: {dasha_info['current_dasha_end'].strftime('%Y-%m-%d')}\n"
        report += f"- 残り期間: {dasha_info['current_dasha_remaining']:.1f}年\n\n"
        report += self.generate_fortune_report(fortune_scores)
        report += "【能力・適性評価】\n"
        career_data = self.numerology_data[str(birth_number)]["career_assessment"]
        for career_key, score in career_data.items():
            career_name = self.career_names[career_key]
            stars = "★" * score + "☆" * (5 - score)
            report += f"- {career_name}: {stars} ({score}/5)\n"
        report += "\n"
        health_risks = ", ".join(self.numerology_data[str(birth_number)]["health_risks"])
        health_advice = ", ".join(self.numerology_data[str(birth_number)]["health_advice"])
        report += "【健康リスクとアドバイス】\n"
        report += f"- リスク: {health_risks}\n"
        report += f"- アドバイス: {health_advice}\n\n"
        lucky_data = self.numerology_data[str(birth_number)]
        report += "【幸運要素】\n"
        report += f"- 幸運の色: {', '.join(lucky_data['lucky_colors'])}\n"
        report += f"- 幸運の宝石: {', '.join(lucky_data['lucky_gems'])}\n"
        report += f"- 幸運の金属: {lucky_data['lucky_metal']}\n"
        report += f"- 幸運の曜日: {lucky_data['lucky_day']}\n"
        report += f"- 幸運の方角: {lucky_data['lucky_direction']}\n"
        return report
    
    def generate_fortune_report(self, fortune_scores: Dict[str, int]) -> str:
        report = "【運勢スコア】\n"
        report += "※現在のサブ周期（アンタルダシャ）における運勢評価です。\n\n"
        score_explanations = {
            5: "大吉 - 非常に良い兆候。積極的に行動を",
            4: "吉 - 良好な状況。チャンスを活かそう",
            3: "中吉 - 一般的な状況。注意深く進め",
            2: "小吉 - やや良いが注意が必要",
            1: "平 - 通常の状況。慎重に",
            0: "平 - 変化なし。維持に努めよ",
            -1: "小凶 - やや悪い兆候。注意を",
            -2: "凶 - 悪い状況。慎重に行動を",
            -3: "大凶 - 非常に悪い兆候。回避を",
            -4: "大凶 - 重大な問題の可能性",
            -5: "大凶 - 非常に危険。慎重に"
        }
        categories = {
            "money": "金運",
            "relation": "人間関係",
            "health": "健康",
            "business": "事業",
            "growth": "成長",
            "family": "家族",
            "competition": "競争"
        }
        for key, name in categories.items():
            score = fortune_scores[key]
            explanation = score_explanations.get(score, "不明 - 評価不能")
            stars = "★" * (score + 5) if score >= 0 else "☆" * (-score + 5)
            report += f"- {name}: {score:+d} [{stars}] {explanation}\n"
        report += "\n"
        return report
    
    def get_langgraph_compatible_data(self, birth_number: int, destiny_number: int,
                                    dasha_info: Dict[str, Any], fortune_scores: Dict[str, int],
                                    full_name: str) -> Dict[str, Any]:
        current_sub_dasha = "N/A"
        current_date = datetime.datetime.now()
        if dasha_info["sub_periods"]:
            for period in dasha_info["sub_periods"]:
                if period["start_date"] <= current_date <= period["end_date"]:
                    current_sub_dasha = period["sub_dasha"]
                    break
            else:
                current_sub_dasha = dasha_info["sub_periods"][0]["sub_dasha"]
        return {
            "core_analysis": {
                "birth_number": birth_number,
                "destiny_number": destiny_number,
                "nakshatra": dasha_info["nakshatra"],
                "nakshatra_pada": dasha_info["nakshatra_pada"],
                "moon_position": dasha_info["moon_position"],
                "current_sub_dasha": current_sub_dasha
            },
            "fortune_scores": fortune_scores,
            "career_assessment": self.numerology_data[str(birth_number)]["career_assessment"]
        }
    
    def generate_llm_interpretation(self, langgraph_data: Dict[str, Any], full_name: str, llm_comment_year: int) -> str:
        try:
            client = OpenAI(
                api_key=os.getenv("DEEPSEEK_API_KEY"),
                base_url="https://api.deepseek.com/v1"
            )
            prompt = f"""あなたはヴェーダ数秘術とインド占星術の専門家です。以下のデータに基づき、専門的で実践的な解釈を生成してください。

【分析対象】
- 名前: {full_name}

【核心分析】
- 誕生数: {langgraph_data['core_analysis']['birth_number']}
- 運命数: {langgraph_data['core_analysis']['destiny_number']}
- ナクシャトラ: {langgraph_data['core_analysis']['nakshatra']}
- パダ: {langgraph_data['core_analysis']['nakshatra_pada']}
- 月の位置: {langgraph_data['core_analysis']['moon_position']:.2f}°
- 現在のダシャー: {langgraph_data['core_analysis']['current_sub_dasha']}

【運勢スコア】
- 金運: {langgraph_data['fortune_scores']['money']}
- 人間関係: {langgraph_data['fortune_scores']['relation']}
- 健康: {langgraph_data['fortune_scores']['health']}
- 事業: {langgraph_data['fortune_scores']['business']}
- 成長: {langgraph_data['fortune_scores']['growth']}
- 家族: {langgraph_data['fortune_scores']['family']}
- 競争: {langgraph_data['fortune_scores']['competition']}

【能力評価】
{self._format_career_assessment(langgraph_data['career_assessment'])}

以下の観点から、専門的で実践的な解釈を日本語で生成してください：
1. カルマとダルマの観点：この人の人生の目的と使命
2. 支配惑星の影響：現在のダシャーがもたらす具体的な影響
3. 現在のダシャー周期の詳細解説：特に注目すべき点
4. 実践的なアドバイス：具体的な行動指針
5. 今後の見通し：{llm_comment_year}年までの運勢の推移と重要なターニングポイント

解釈は、ヴェーダ数秘術の正統な原則に基づき、占い初心者にも理解しやすい説明をしてください。インドの伝統的知恵を尊重しつつ、現代的な視点も取り入れてください。"""
            response = client.chat.completions.create(
                model="deepseek-chat",
                messages=[
                    {"role": "system", "content": "あなたはヴェーダ数秘術とインド占星術の専門家です。専門的で実践的な解釈を提供してください。"},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7,
                max_tokens=1500
            )
            return response.choices[0].message.content
        except Exception as e:
            error_msg = str(e)
            if "model" in error_msg.lower():
                error_msg = "モデル名が正しくありません。'deepseek-chat'を使用してください。"
            elif "api_key" in error_msg.lower():
                error_msg = "APIキーが無効または設定されていません。"
            return (f"※LLMによる詳細解釈の生成中にエラーが発生しました。\n"
                    f"エラー詳細: {error_msg}\n"
                    f"【修正すべき点】\n"
                    f"1. モデル名を'deepseek-chat'に変更\n"
                    f"2. .envファイルに正しいDEEPSEEK_API_KEYを設定")
    
    def _format_career_assessment(self, career_data: Dict[str, int]) -> str:
        formatted = ""
        for career_key, score in career_data.items():
            career_name = self.career_names[career_key]
            stars = "★" * score + "☆" * (5 - score)
            formatted += f"- {career_name}: {stars} ({score}/5)\n"
        return formatted

def process_user_input(state: VedicNumerologyState) -> VedicNumerologyState:
    try:
        if "graph_end_year" not in state or state["graph_end_year"] is None:
            state["graph_end_year"] = 2030
        if "llm_comment_year" not in state or state["llm_comment_year"] is None:
            state["llm_comment_year"] = 2011
        location_info = get_location_info(state["user_location"])
        if not location_info:
            logger.error(f"指定された出生地 '{state['user_location']}' が見つかりません")
            return {
                **state,
                "error": f"指定された出生地 '{state['user_location']}' が見つかりません",
                "vedic": None
            }
        latitude = location_info["latitude"]
        longitude = location_info["longitude"]
        timezone = location_info["timezone"]
        birth_datetime = datetime.datetime.combine(
            state["birth_date"],
            datetime.time(0, 0, 0)
        )
        try:
            vedic = VedicNumerology()
            logger.info("VedicNumerologyインスタンスの生成に成功")
        except Exception as e:
            logger.error(f"VedicNumerologyインスタンスの生成に失敗: {str(e)}")
            return {
                **state,
                "error": f"VedicNumerologyインスタンスの生成に失敗: {str(e)}",
                "vedic": None
            }
        return {
            **state,
            "latitude": latitude,
            "longitude": longitude,
            "timezone": timezone,
            "birth_datetime": birth_datetime,
            "vedic": vedic,
            "error": None
        }
    except Exception as e:
        logger.error(f"入力処理エラー: {str(e)}")
        return {
            **state,
            "error": f"入力処理エラー: {str(e)}",
            "vedic": None
        }

def get_location_info(location_name: str) -> Dict[str, Any]:
    locations = {
        "ロサンゼルス": {"latitude": 34.0522, "longitude": -118.2437, "timezone": "Ameri-ca/Los_Angeles"},
        "東京": {"latitude": 35.6895, "longitude": 139.6917, "timezone": "Asia/Tokyo"},
        "ニューヨーク": {"latitude": 40.7128, "longitude": -74.0060, "timezone": "Ameri-ca/New_York"},
        "ロンドン": {"latitude": 51.5074, "longitude": -0.1278, "timezone": "Europe/London"},
        "デリー": {"latitude": 28.7041, "longitude": 77.1025, "timezone": "Asia/Kolkata"}
    }
    location_name = location_name.strip()
    if location_name in locations:
        logger.info(f"場所 '{location_name}' が見つかりました: {locations[location_name]}")
        return locations[location_name]
    location_name_lower = location_name.lower()
    for name, info in locations.items():
        if location_name_lower == name.lower():
            logger.info(f"ファジーマッチで '{location_name}' が '{name}' として見つかりました: {info}")
            return info
    logger.error(f"場所 '{location_name}' が見つかりませんでした")
    return None

def calculate_numerology(state: VedicNumerologyState) -> VedicNumerologyState:
    try:
        if state.get("vedic") is None:
            logger.error("VedicNumerologyインスタンスがありません")
            return {
                **state,
                "error": "VedicNumerologyインスタンスがありません"
            }
        vedic = state["vedic"]
        birth_number = vedic.calculate_birth_number(state["birth_date"])
        destiny_number = vedic.calculate_destiny_number(state["full_name"])
        dasha_info = vedic.calculate_dasha_period(
            state["birth_datetime"],
            state["latitude"],
            state["longitude"]
        )
        fortune_scores = vedic.calculate_fortune_scores(birth_number, dasha_info)
        fortune_trends = vedic.calculate_fortune_trends(
            birth_number,
            state["birth_date"],
            state["latitude"],
            state["longitude"],
            end_year=state["graph_end_year"]
        )
        location_info = {
            "name": state["user_location"],
            "latitude": state["latitude"],
            "longitude": state["longitude"],
            "timezone": state["timezone"]
        }
        basic_report = vedic.generate_basic_report(
            birth_number,
            destiny_number,
            dasha_info,
            fortune_scores,
            state["full_name"],
            state.get("original_name_script"),
            location_info
        )
        langgraph_data = vedic.get_langgraph_compatible_data(
            birth_number,
            destiny_number,
            dasha_info,
            fortune_scores,
            state["full_name"]
        )
        return {
            **state,
            "birth_number": birth_number,
            "destiny_number": destiny_number,
            "dasha_info": dasha_info,
            "fortune_scores": fortune_scores,
            "fortune_trends": fortune_trends,
            "basic_report": basic_report,
            "langgraph_data": langgraph_data,
            "error": None
        }
    except Exception as e:
        logger.error(f"計算エラー: {str(e)}")
        return {
            **state,
            "error": f"計算エラー: {str(e)}"
        }

def generate_fortune_trend_graph(state: VedicNumerologyState) -> VedicNumerologyState:
    if state.get("error") or not state.get("fortune_trends"):
        return state
    try:
        import japanize_matplotlib  # 日本語フォント対応
        import matplotlib.pyplot as plt
        
        trends = state["fortune_trends"]
        years = trends["years"]
        end_year = state["graph_end_year"]
        plt.figure(figsize=(12, 8))
        plt.title(f'5年ごとの運勢トレンド ({years[0]}年～{end_year}年)', fontsize=16)
        categories = {
            "money": "金運",
            "relation": "人間関係",
            "health": "健康",
            "business": "事業",
            "growth": "成長",
            "family": "家族",
            "competition": "競争"
        }
        colors = ['r', 'g', 'b', 'c', 'm', 'y', 'k']
        for i, (key, name) in enumerate(categories.items()):
            plt.plot(years, trends["trends"][key], 
                    color=colors[i], 
                    marker='o', 
                    linestyle='-',
                    linewidth=2,
                    markersize=8,
                    label=name)
        plt.xlabel('年', fontsize=12)
        plt.ylabel('運勢スコア (-5～+5)', fontsize=12)
        plt.grid(True, linestyle='--', alpha=0.7)
        plt.legend(loc='best')
        plt.yticks(range(-5, 6))
        plt.xticks(years, rotation=45)
        filename = "Steve_Jobs_fortune_trend.png"
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        plt.show()  # Jupyter Notebookでグラフをインライン表示
        plt.close()
        return {
            **state,
            "graph_status": f"【運勢トレンドグラフ】出生年から5年ごとの運勢トレンドを{end_year}年までグラフ化しました。グラフは '{filename}' として保存されました。",
            "graph_filename": filename
        }
    except Exception as e:
        logger.error(f"グラフ生成エラー: {str(e)}")
        return {
            **state,
            "error": f"グラフ生成エラー: {str(e)}"
        }

def llm_interpretation(state: VedicNumerologyState) -> VedicNumerologyState:
    if state.get("error") or not state.get("langgraph_data"):
        return state
    try:
        vedic = state["vedic"]
        llm_interpretation = vedic.generate_llm_interpretation(
            state["langgraph_data"],
            state["full_name"],
            state["llm_comment_year"]
        )
        return {
            **state,
            "llm_interpretation": llm_interpretation
        }
    except Exception as e:
        logger.error(f"LLM解釈エラー: {str(e)}")
        return {
            **state,
            "error": f"LLM解釈エラー: {str(e)}"
        }

def display_results(state: VedicNumerologyState) -> VedicNumerologyState:
    if state.get("error"):
        print(f"エラーが発生しました: {state['error']}")
        return state
    print("=" * 70)
    print(f"{state['full_name']} のヴェーダ数秘術分析結果")
    print("=" * 70)
    print(state["basic_report"])
    if state.get("llm_interpretation"):
        print("\n" + "=" * 70)
        print("【LLMによる専門的解釈】")
        print("=" * 70)
        print(state["llm_interpretation"])
    if state.get("graph_status"):
        print("\n" + state["graph_status"])
    return state

def create_workflow() -> Any:
    from langgraph.graph import StateGraph, END
    workflow = StateGraph(VedicNumerologyState)
    workflow.add_node("process_user_input", process_user_input)
    workflow.add_node("calculate_numerology", calculate_numerology)
    workflow.add_node("generate_fortune_trend_graph", generate_fortune_trend_graph)
    workflow.add_node("llm_interpretation", llm_interpretation)
    workflow.add_node("display_results", display_results)
    workflow.set_entry_point("process_user_input")
    workflow.add_edge("process_user_input", "calculate_numerology")
    workflow.add_edge("calculate_numerology", "generate_fortune_trend_graph")
    workflow.add_edge("generate_fortune_trend_graph", "llm_interpretation")
    workflow.add_edge("llm_interpretation", "display_results")
    workflow.add_edge("display_results", END)
    return workflow

if __name__ == "__main__":
    app = create_workflow().compile()
    initial_state = VedicNumerologyState(
        full_name="Steve Jobs",
        birth_date=datetime.date(1955, 2, 24),
        birth_datetime=datetime.datetime(1955, 2, 24, 19, 0),
        user_location="ロサンゼルス",
        original_name_script=None,
        latitude=None,
        longitude=None,
        timezone=None,
        vedic=None,
        birth_number=None,
        destiny_number=None,
        dasha_info=None,
        fortune_scores=None,
        fortune_trends=None,
        basic_report=None,
        langgraph_data=None,
        llm_interpretation=None,
        error=None,
        graph_end_year=2012,
        llm_comment_year=2011,
        graph_filename=None
    )
    result = app.invoke(initial_state)
    # ---
    print("=============")
    print("最終ステート:")
    print(result)

```

D先生： “いよいよ、例の英雄に関するLLM推論の結果は？”

================================================

【Steve Jobs 様のヴェーダ数秘術分析結果】

================================================

【基本分析】
誕生数: 1 (सूर्य (Surya: 太陽))
- 強み: リーダーシップ, 自信, 意志力, 創造性, 独立心
- 弱み: 独善的, 頑固, 自己中心, 威圧的
- 人生テーマ: 自己実現、リーダーシップの確立、個人の力の発揮

運命数: 4 (कुज (Kuja: 火星))
- 人生の目的: 挑戦への対応、エネルギーの管理、自己防衛
- 幸運の色: 赤, オレンジ, 茶色

【ナクシャトラ分析】
- 月の位置: 352.37°
- ナクシャトラ: रेवती (Revati: レーヴァティー、富める者) (बुध (Budh: 水星))
- パダ: पद 2 (Pada 2: 2つ目の四分位)
- 特性: 成長、発展、進化

【ダシャー周期分析】
- 現在のダシャー: बुध (Budh: 水星)
- 開始日: 1962-11-02
- 終了日: 2000-03-27
- 残り期間: 9.3年

【運勢スコア】
※現在のサブ周期（アンタルダシャ）における運勢評価です。

- 金運: -2 [☆☆☆☆☆☆☆] 凶 - 悪い状況。慎重に行動を
- 人間関係: -2 [☆☆☆☆☆☆☆] 凶 - 悪い状況。慎重に行動を
- 健康: -2 [☆☆☆☆☆☆☆] 凶 - 悪い状況。慎重に行動を
- 事業: +0 [★★★★★] 平 - 変化なし。維持に努めよ
- 成長: -3 [☆☆☆☆☆☆☆☆] 大凶 - 非常に悪い兆候。回避を
- 家族: -2 [☆☆☆☆☆☆☆] 凶 - 悪い状況。慎重に行動を
- 競争: -2 [☆☆☆☆☆☆☆] 凶 - 悪い状況。慎重に行動を

【能力・適性評価】
- 教師・人文系・ライター: ★★★☆☆ (3/5)
- 科学者・数学者・エンジニア: ★★☆☆☆ (2/5)
- 宗教家・哲学者: ★★★☆☆ (3/5)
- オフィスワーカー・マネージャー: ★★★★☆ (4/5)
- シェフ・アーティスト: ★★★★★ (5/5)
- エンターテイナー・ミュージシャン: ★★★★★ (5/5)
- 経営者・CEO: ★★★★★ (5/5)
- 政治家・公務員: ★★★★☆ (4/5)

【健康リスクとアドバイス】
- リスク: 心臓, 目, 高血圧, 頭痛
- アドバイス: ストレス管理, 適度な運動, 十分な休息

【幸運要素】
- 幸運の色: 金色, オレンジ, 赤
- 幸運の宝石: ルビー, サンゴ
- 幸運の金属: 金
- 幸運の曜日: 日曜日
- 幸運の方角: 東

================================================

【LLMによる専門的解釈】

================================================

**スティーブ・ジョブズのヴェーダ数秘術＆インド占星術による専門的解釈**

### 1. カルマとダルマの観点：人生の目的と使命
- **誕生数1（リーダーシップ）**と**運命数4（実践的構築）**の組み合わせは、「革新的なアイデアを具体的な形に変える」という使命を示唆。レーヴァティー・ナクシャトラ（富と完成を司る）が、彼の「製品の完全性へのこだわり」と符合。
- **ダルマ（社会的使命）**：技術と芸術の融合（5つ星のアーティスト/経営者能力）を通じ、人類の生活様式を変革することが運命付けられていました。仏教への傾倒（宗教家3つ星）も、ミニマリズムという形でApple製品に反映。

### 2. 支配惑星の影響：水星ダシャーの具体的影響
- **水星（ブッダ）**は知性・コミュニケーションを司り、現在：
  - **強み**：製品プレゼンの天才性（例：iPhone発表会）が顕著に
  - **課題**：水星の弱い位置（健康-2）が2011年の健康悪化と関連
  - **金運-2**：収益より「理想追求」が優先される傾向（例：NeXT時代）

### 3. 現在のダシャー周期の注目点
- **水星-ケートゥ周期（2007-2011）**：
  - **転換点**：2007年iPhone発表（水星の革新性が顕現）
  - **警告サイン**：健康面で「膵臓」に注意（レーヴァティーは体の末端を支配）
  - **人間関係-2**：経営陣との摩擦（例：ジョン・スカリーとの確執）が再燃する可能性

### 4. 実践的アドバイス
- **健康管理**：
  - 水星の弱さを補うため「緑色の野菜」「ヘマタイト石」を推奨
  - 毎日18分間の瞑想（誕生数1の人が集中力を保つ黄金時間）
- **事業運**：
  - パダ2の特性を活かし「既存製品の微調整」より「全く新しいカテゴリー創造」（例：iPad）に集中
  - 競争-2を逆手に取る「ブルーオーシャン戦略」が有効

### 5. 2011年までの運勢見通し
- **2010年（水星-金星）**：
  - iPad発表（4月）で事業運が一時上昇
  - 金運-2のため株価より「業界への影響力」で成功を測るべき
- **2011年（水星-太陽）**：
  - 太陽のダシャーが健康運をさらに圧迫（8-10月がピーク）
  - 重要なターニングポイント：後継者育成（ティム・クックへの権限委譲）が運命数4の「持続可能なシステム構築」使命を完結

**伝統的知恵からの補足**：
レーヴァティー・ナクシャトラ生まれは「最後のナクシャトラ」として、人生の完結を重視します。ジョブズの「スピーチで自らの死を予感させる表現」は、この星の影響と考えられます。ヴェーダの教えでは、この時期に「ダーナ（寄付）」を行うことでカルマが軽減されるとされます。


D先生： “LLMが、推論結果を現実とむりやり合わせているようです。おかしいと思っていたら、プロンプトに当人の名前を入れているじゃないですか。”

QEU:FOUNDER ： “ただし、この能力評価は、数秘術の結果です。これは、かなりイケているでしょ？”

D先生： “さすがだなあ・・・。”

QEU:FOUNDER ： “今回は、プロジェクトの最初のステップです。この程度の結果になるのは、やむを得ないです。”

D先生： “改善する部分がたくさんありますね。 “

QEU:FOUNDER  ： “課題は、数秘術のメトリックス（還元数）をもっと増やすこと。そして、ナクシャトラを改善することですね。”

D先生： “LangGraphで造られているので、プログラムの拡張が簡単でしょう。 “

QEU:FOUNDER  ： “jsonファイルが増えるでしょう・・・。”



## ～ まとめ ～

QEU:FOUNDER ： “また一年の、この時期が来ます。”

![imageINDS2-40-8](/2025-08-14-QEUR23_INDHS40/imageINDS2-40-8.jpg) 

C部長：“ことしは、とても大事な件がありますからね。”

**(815氏)**

![imageINDS2-40-9](/2025-08-14-QEUR23_INDHS40/imageINDS2-40-9.jpg) 

**(366氏)**

![imageINDS2-40-10](/2025-08-14-QEUR23_INDHS40/imageINDS2-40-10.jpg) 

QEU:FOUNDER ： “まあ、どうなるのかは知らんが、**「ファイティング・ポーズ」**は出してほしい。”

C部長：“どんなポーズ？”

![imageINDS2-40-11](/2025-08-14-QEUR23_INDHS40/imageINDS2-40-11.jpg) 

D先生：“こんなポーズです。”

